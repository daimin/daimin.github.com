<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0025)http://daimin.github.io/ -->
<html>
<head>
    

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="keywords" content="学习vue.js" />
    <meta name="description" content="vue对象定义，常用指令和模板的简单使用{{ var }} 用来输出变量var vm = new V..." />
    <link rel="shortcut icon" href="/favicon.ico" />

    <title>学习vue.js | 茶瓯葱丝</title>
    <link rel="stylesheet" type="text/css" href="/styles/style.css">
    <link rel="Stylesheet" type="text/css" href="/js/prettify/desert.css" />
    <link rel="stylesheet" type="text/css" href="/styles/bootstrap-jian.css">
    <script type="text/javascript"  src="/js/prettify/prettify.js"></script>
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://daimin.github.io/rss.xml">
</head>
<body>
		<div id="logo">
			<span id="motto"></span>
			<h1><a href="/index.html" >茶瓯葱丝</a>
            <form onsubmit="return dispatch()" style="display:inline">
            <span style="width: 240px; height: 26px; margin-left:24px; background-size: 240px 26px; background-image: url('/image/qbar_light@2x.png'); background-repeat: no-repeat; display: inline-block;">
            <input type="text" maxlength="40" name="q" id="q" value="">
            </span>
            </form>
            </h1>
            
        </div>
<div id="wrapper">
<div id="content" class="index">
     
<div id="sidebar">
        <ul>
            <li>
                <a href="/index.html">首页</a>
                <ul>
                        <li><a href="/tags/python.html" title="python"> python</a></li>
                        <li><a href="/tags/php.html" title="php"> php</a></li>
                        <li><a href="/tags/mysql.html" title="mysql"> mysql</a></li>
                        <li><a href="/tags/nginx.html" title="nginx"> nginx</a></li>
                        <li><a href="/tags/markdown.html" title="markdown"> markdown</a></li>
                </ul>
            </li>
            <li><a href="/tags/">标签</a></li>
            <li><a href="http://daimin.github.io/rss.xml">订阅</a></li>
            <li><a href="/links.html">友链</a></li>
            <li><a href="/docs/index.html">文档</a></li>
                <li><a href="/posts/liu-yan-ban.html" title="留言">留言</a></li>
            
        </ul>
<!--         <div class="ad-panel" onclick="location.href='https://www.facebook.com/NancyatJarliet'" style="cursor: pointer;">
            <div class="ad-desc">
            <p>实体娃娃(Sex Doll).<br/><a href="mailto:sales5@jarliet.com">sales5@jarliet.com</a></p>
            </div>
           <img src="/image/ads/erwama.jpg" style="float:right;margin-top:3px;" /> 
        </div> -->
        
    </div>

<div id="main">
<h2 class="post-title">学习vue.js</h2>
<div class="cnt">
<h1>vue对象定义，常用指令和模板的简单使用</h1>
<p><code>{{ var }}</code> 用来输出变量</p>
<pre><code>var vm = new Vue({
    el: '#app',  # 对应一个DOM 元素进行挂载
    create(){ // 页面加载未渲染html之前执行。

    },
    mounted(){ //渲染html后再执行。由于created在html模板生产之前所以无法对Dom进行操作而mounted可以。

    },
    computed{ // 计算属性，在使用的时候直接返回，而且带有缓存功能，如果相关的值未改变将不会重复计算。默认只有getter，也可以设置setter

    },
    watch{ //监控变量或方法，如果是监控方法，需要配合computed来使用。如果监控对象需要深度watch，比如有一个对象a={b:1}，监控b。
            // 1. 'a.b'(newval,oldval){}
            // 2. 这里也可以用computed，将变量作为计算属性返回
            // 3. 又或者深度监听a{hander(newval,oldval),deep:true}（这个性能比较差，因为只要对象中任意变量改动都会调用handler）。

    },
    data(){ # data是Vue对象的属性，一般最好作为方法return，可以避免数据污染
        return {
            newPerson: {
            name: '',
            age: 0,
            sex: 'Male'
            },
            peoples:[ ]
        }
    },
    methods:{ # vue对象的方法
        createPerson: function(){
            this.peoples.push(this.newPerson);
            // 添加完newPerson对象后，重置newPerson对象
            this.newPerson = {name: '', age: 0, sex: 'Male'}
        }
    }
})
</code></pre>
<ol>
<li>
<p>常用指令</p>
<ul>
<li>v-bind 指令可以用于响应式地更新 HTML 属性，缩写为冒号 : </li>
<li>v-for会对使用它的标签进行循环</li>
<li>v-on 用于监听 DOM 事件，缩写为@</li>
<li>v-model 指令在表单控件元素上创建双向数据绑定</li>
<li>v-show 用于根据条件展示元素</li>
<li>v-if和v-show类似，不过他可以接v-else，还有v-else-if<br />
    v-if 和v-show类似，不过二者还有有区别，v-if切换消耗较大，v-show初始化时消耗较大，因为v-if是惰性渲染。频繁变动的用v-show，否则用v-if</li>
<li>v-once可以控制变量变化时绑定的数据不变化。</li>
<li>v-html用来原始输出html</li>
</ul>
</li>
<li>
<p>组件</p>
<ol>
<li>
<p>使用组件<br />
应该在挂载元素范围内使用组件</p>
<p><div id="app">
    <!-- 3. #app是Vue实例挂载的元素，应该在挂载元素范围内使用组件-->
    <my-component></my-component>
</div></p>
<pre><code>// 创建一个组件构造器
var myComponent = Vue.extend({
    template: '&lt;div&gt;This is my first component!&lt;/div&gt;'
})

new Vue({
    el: '#app',
    components: {
        // 可以将myComponent组件注册到Vue实例下
        'my-component' : myComponent
    }
});

// 也可以全局注册组件。可以在页面中所有的vue挂载元素中使用该组件，不可以在非vue挂载元素中使用
Vue.component('my-component', myComponent)
</code></pre>
</li>
<li>
<p>组件模板</p>
<pre><code>&lt;script type="text/x-template" id="myComponent"&gt; &lt;!-- html5之前的写法 --&gt;
    &lt;div&gt;This is a component!&lt;/div&gt;
&lt;/script&gt;
&lt;template id="myComponent"&gt; &lt;!-- html5支持该标签 --&gt;
    &lt;div&gt;This is a component!&lt;/div&gt;
&lt;/template&gt;
Vue.component('my-component',{
    template: '#myComponent'
})
new Vue({
    el: '#app'
})
</code></pre>
</li>
<li>
<p>嵌套组件</p>
<pre><code>&lt;div id="app"&gt;
    &lt;parent-component&gt;
    &lt;/parent-component&gt;
&lt;/div&gt;
var Child = Vue.extend({
    template: '&lt;p&gt;This is a child component!&lt;/p&gt;'
})

var Parent = Vue.extend({
    // 在Parent组件内使用&lt;child-component&gt;标签 , template中必须有一个根节点
    template :'&lt;div&gt;&lt;p&gt;This is a Parent component&lt;/p&gt;&lt;child-component&gt;&lt;/child-component&gt;&lt;/div&gt;',
    components: {
        // 局部注册Child组件，该组件只能在Parent组件内使用
        'child-component': Child
    }
})

// 全局注册Parent组件
Vue.component('parent-component', Parent)

new Vue({
    el: '#app'
})
</code></pre>
</li>
</ol>
</li>
<li>
<p>使用props<br />
    父组件的数据需要通过 prop 才能下发到子组件中，也就是props是子组件访问父组件数据的唯一接口。<br />
    如果子组件想要引用父元素的数据，那么就在其prop里面声明一个变量（比如a），这个变量就可以引用父元素的数据。然后在模板里渲染这个变量（前面的a），这时候渲染出来的就是父元素里面的数据。</p>
<pre><code>&lt;div id="app"&gt;
&lt;!--在子组件中定义prop时，使用了camelCase命名法。由于HTML属性不区分大小写，camelCase的prop用于属性时，需要转为 kebab-case（短横线隔开）。例如，在prop中定义的myName，在用作属性时需要转换为my-name。--&gt;
    &lt;my-component :my-name="name" :my-age="age"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;template id="myComponent"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th colspan="2"&gt;
                子组件数据
            &lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;my name&lt;/td&gt;
            &lt;td&gt;{{ myName }}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;my age&lt;/td&gt;
            &lt;td&gt;{{ myAge }}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/template&gt;
var vm = new Vue({
    el: '#app',
    data: {
        name: 'keepfool',
        age: 28
    },
    components: {
        'my-component': {
            template: '#myComponent',
            props: ['myName', 'myAge']
        }
    }
})
</code></pre>
</li>
<li>
<p>使用slot <br />
    slot就是将父组件的DOM显示在子组件中，父组件决定内容，子组件决定位置。</p>
<ol>
<li>
<p>没有名字的slot，就是父节点模板中子组件标签的内容作为slot显示在子组件的DOM中。</p>
<pre><code>&lt;my-component&gt;
    &lt;h1&gt;Hello Vue.js!&lt;/h1&gt;  &lt;!--将会替换子组件的slot标签来展示--&gt;
&lt;/my-component&gt;
&lt;template id="myComponent"&gt;
    &lt;div class="content"&gt;
        &lt;h2&gt;This is a component!&lt;/h2&gt;
        &lt;slot&gt;如果没有分发内容，则显示slot中的内容&lt;/slot&gt;
        &lt;p&gt;Say something...&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
<li>
<p>具名的slot，父节点中的有slot属性的标签将会替换子组件中具名的slot。</p>
<pre><code>&lt;!-- slot属性为header的标签将会提交子组件中name等于header的slot --&gt;
&lt;header class="dialog-header" slot="header"&gt;
    &lt;h1 class="dialog-title"&gt;
        提示信息
    &lt;/h1&gt;
&lt;/header&gt;
&lt;template id="dialog-template"&gt;
    &lt;div&gt;
        &lt;slot name="header"&gt;
        &lt;/slot&gt;
    &lt;/div&gt;
 &lt;/template&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>$emit</p>
<ol>
<li>父组件可以使用 props 把数据传给子组件。(这个上面已经讨论过)</li>
<li>可以使用 $emit 触发组件的自定义事件。 用这个其实可以将子组件的数据传递给任一组件。其实这个容易使逻辑变复杂，不推荐过分使用。
    vm.$emit( event, arg ) //触发当前实例上的事件<br />
    vm.$on( event, func) //监听event事件后运行 fn； </li>
<li>还可以单独new一个Vue实例，专门用来$emit发射自定义事件和$on监听自定义事件。</li>
</ol>
</li>
<li>
<p>ref</p>
<p>可以给子组件的标签的ref属性指定一个名称，然后就可以通过其父组件的$refs来引用这个组件。
比如：</p>
<pre><code>&lt;childcp ref="acp"&gt;&lt;/childcp&gt;
this.$parent.$refs.acp // 可以引用这个子组件
this.$root // 指向根组件 
this.$parent.$ref.acp.$emit('aevent', []) //向acp发射自定义事件，可以在这个组件中this.$on来监听
</code></pre>
</li>
</ol>
</div>

<div style="margin-top:24px;margin-bottom:12px;display: block;">
<hr/>
</div>
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '77f443870397c7d22754',
  clientSecret: '7dfb40a18b6bc6962686748e3a46e0581ad024d2',
  repo: 'daimin.github.com',      // The repository of store comments,
  owner: 'daimin',
  admin: ['daimin'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})

gitalk.render('gitalk-container')
</script>

</div>


</div>
<div id="footer">
	<span style="color:#bbb;font-size:12px">
	&copy; Powered by <a href="https://github.com/daimin/daimin.github.com" title="sologs">sologs</a> 
	</span>
	<p style="clear:both"></p>
</div>
</div>
<script type="text/javascript">
function hasClass(obj, cls) {  
    return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));  
}
function addClass(obj, cls) {  
    if (!this.hasClass(obj, cls)) obj.className += " " + cls;  
} 

function render_pretty(){
    var pres = document.getElementsByTagName("pre");
    for(var i = 0, len = pres.length; i < len; i++){
        addClass(pres[i], "prettyprint");
    }
    prettyPrint();

}

(function(){
   var mattos = [
   "人生没有对错，只有选择后的坚持，不后悔，走下去，就是对的。",
   "生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。",
   "宁愿做过了后悔，也不要错过了后悔。",
   "不要拿小人的错误来惩罚自己，不要在这些微不足道的事情上折磨浪费自己的宝贵时间。",
   "环境不会改变，解决之道在于改变自己。",
   "勇气是控制恐惧心理，而不是心里毫无恐惧。",
   "两个人共尝一个痛苦只有半个痛苦，两个人共享一个欢乐却有两个欢乐。",
   "好好管教自己，不要管别人。",
   "得之坦然，失之淡然，顺其自然，争其必然。",
   "人生是一条没有回程的单行线，上帝不会给你一张返程的票。",
   "把事情办好的秘密就是行动。成功之路就是有条理思考之后的行动！行动！行动！",
   "人生是一场旅行，在乎的不是目的地，是沿途的风景以及看风景的心情。",
   "放弃谁都可以，千万不要放弃自己！",
   "长得漂亮是优势，活得漂亮是本事。",
   "人生最大的错误是不断担心会犯错。",
   "一个人可以被毁灭，但不能给打败 -- 《老人与海》。",
   "要么不要开始，要么不要结束。",
   "要做的事情总找得出时间和机会，不要做的事情总找得出借口。",
   "我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！",
   "少说多做，句句都会得到别人的重视；多说少做，句句都会受到别人的忽视。",
   "记住该记住的，忘记该忘记的。改变能改变的，接受不能改变的。",
   "我所学到的任何有价值的知识都是由自学中得来的。——达尔文",
   ];
   document.getElementById("motto").innerHTML = mattos[parseInt(Math.random() * mattos.length)];
   
})();

window.onload = function(){
   render_pretty();
};

var dispatch = function() {
    q = document.getElementById("q");
    if (q.value != "") {
        //window.open('http://www.baidu.com/s?si=daimin.github.io&cl=3&ct=2097152&tn=bds&word=' + q.value, "_blank");
        window.open('https://www.google.com.hk/search?q=site:daimin.github.io ' + q.value + '&gws_rd=cr,ssl', '_blank');
        return false;
    } else {
        return false;
    }
};

</script>
<script type="text/javascript" src="/js/jimdoclockzip.js"></script>
<script type="text/javascript">
var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5814730'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/stat.php%3Fid%3D5814730%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
</script>
<a href="http://s11.flagcounter.com/more/2dzW"><img src="https://s11.flagcounter.com/count2/2dzW/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_0/labels_0/pageviews_0/flags_0/percent_0/" alt="Flag Counter" border="0"></a>
</body>
</html>
