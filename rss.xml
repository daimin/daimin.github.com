<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
    <title>茶瓯葱丝</title>  
    <link>daimin.github.io</link>  
	<description>本站内容为个人技术博客及其它软件编程信息。本站采用python开发，用markdown来进行编辑，生成静态文本放在github上。</description>  
    <language>zh-cn</language>  
    <generator>sologd</generator>  
    <item>  
		<title>golang相关</title>  
		<link>http://daimin.github.io//posts/golang-xiang-guan.html</link>  
		<description>&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;变量定义： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和其它语言不一样，它将类型放在后面，&lt;code&gt;var a int&lt;/code&gt; ，它不需要分号。还可以这样声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var (
    v1 int
    v2 string
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化：如下三种都是合法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var v1 int = 10
var v2 = 10 //编译器可以自动推导出类型
v3 := 10  //不需要var，声明和初始化一起，声明后的不能用:=初始化
* 赋值，它也支持这种 `i, j = j, i`，这里i和j就交换了值。
* 字符串类型必须是双引号
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字面常量就是硬编码的数字，字符串等等。&lt;/li&gt;
&lt;li&gt;定义常量: &lt;code&gt;const A int = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;const (
    A = iota //在const使用重置为0
    B
)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;golang的数组是大小不可以变的，定义的时候就要给定，&lt;code&gt;[32] byte&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组切片后就成了另外一个类型了：数组切片，这个时候大小就可以自动变化了。&lt;/li&gt;
&lt;li&gt;数组遍历用range关键字，也可以用传统的for语句，推荐range&lt;/li&gt;
&lt;li&gt;数组是值类型，赋值和参数传递的时候都会复制所有元素。&lt;/li&gt;
&lt;li&gt;数组切片：myArray[:5]将数组切片，也可以make一个数组切片&lt;pre&gt;&lt;code&gt;mys1 := make([]int, 5) // 初始值为0，初始大小为5
mys2 := make([]int, 5, 10) //初始值为0，初始大小为5，预留10个大小
mys3 := []int{1,2,3,4,5} //直接初始化一个包含5个元素的切片
* cap函数，返回数组(**这里的数组包括切片，下同**)大小;len函数返回当前的个数;append给数组添加元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map，键值对集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var myMap map[string] PersonInfo&lt;/code&gt;，键类型是string，值类型为PersonInfo&lt;/li&gt;
&lt;li&gt;make创建map：&lt;code&gt;myMap = make(map[string] PersonInfo, 100)&lt;/code&gt;，创建map并指定初始大小&lt;/li&gt;
&lt;li&gt;delete删除元素 &lt;code&gt;delete(myMap, &#34;1234&#34;)&lt;/code&gt;，删除键值&#34;1234&#34;的元素&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找&lt;/p&gt;
&lt;p&gt;value, ok := myMap[&#34;1234&#34;]
if ok { // finded
    // do what you want
}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error接口，所有的错误都实现了这个接口&lt;/li&gt;
&lt;li&gt;defer 相当于try...catch语句的finally。&lt;/li&gt;
&lt;li&gt;panic打印错误，并终止流程，病返回调用函数处，由上层panic继续执行，知道goroutine被终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;golang接口很宽松，只要实现了方法就算是实现了接口，并不需要显示的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;interface{} 表示any类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类，golang的类就是结构体&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象是引用类型，而结构体是值类型&lt;/p&gt;
&lt;p&gt;//建立对象，它是引用类型（推荐，因为类一般比较大，引用省内存）
rect1 := new(Rect)
rect2 := &amp;amp;Rect{}
rect3 := &amp;amp;Rect{0, 0, 100, 200}
rect4 := &amp;amp;Rect{width: 100, height:200}&lt;/p&gt;
&lt;p&gt;// 也可以，它是值类型
rect = Rect{}
rect = Rect{0, 0, 100, 200}
rect = Rect{width: 100, height:200}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;goroutine就是go实现的协程，语言级实现，函数调用前面加一个go关键字就是并发执行了。&lt;/li&gt;
&lt;li&gt;golang的并发通讯，推荐channel，如：&lt;code&gt;ch := make(chan int)&lt;/code&gt;，&lt;code&gt;ch &amp;lt;- 1&lt;/code&gt;表示向chan中写入1，&lt;code&gt;&amp;lt;-ch&lt;/code&gt;表示从chan中读取，在读取。写入后操作是阻塞的，直到被读取，读取钱读取也是阻塞的，知道被写入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var ch2 chan&amp;lt;- float64&lt;/code&gt; 单向的channel，只能被写；&lt;code&gt;var ch3 &amp;lt;-chan int&lt;/code&gt;只能被读。&lt;/li&gt;
&lt;li&gt;close(ch)关闭channel&lt;/li&gt;
&lt;li&gt;多核运行，可能需要设置&lt;code&gt;runtime.GOMAXPROCS(16)&lt;/code&gt; 16就是核心数&lt;/li&gt;
&lt;li&gt;锁，实现并发通讯的另一种方式，原则上就是锁住共享内存&lt;/li&gt;
&lt;li&gt;实现IPC就只有两种方式：&lt;strong&gt;共享内存&lt;/strong&gt;和&lt;strong&gt;消息传递&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如上，先这样。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2017-03-21</pubDate>  
    </item>  
    <item>  
		<title>数组参数还是对象参数</title>  
		<link>http://daimin.github.io//posts/php-shuzu-args-or-duixiang-args.html</link>  
		<description>&lt;p&gt;在PHP中给函数传参数的时候，一般来说为了避免参数过长我们可以选择传数组或者是封装一个参数类来传对象。
&lt;strong&gt;我的看法是对象肯定是优于数组。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PHP中对于数组参数是值拷贝的，所以一般来说会更加的耗费内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PHP中也是可以通过引用传递数组，但是调用方却不知道方法的定义的时候具体是引用还是值参数，除非跳转到方法的定义处查看，而且如果方法中改变了该数组的某个元素的值，会造成比较晦涩的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象传递都是传引用，大家都知道对象参数的值是可能被改变的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组参数传递的时候，调用方可以随意的在数组中添加元素，而方法中却不知道其使用的参数具体的值，如果调用方少传了某些参数，可能会导致方法直接报错。而且也很难理解方法中各个元素的含义，只能通过注释的方式来说明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象参数，传递的变量是比较固定的，是在对象参数的类中定义的，开发者很容易就知道具体变量的含义，也可以对该类的用途进行说明。这对于代码的可读性有很大的好处。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象传递的缺点就在于可能需要额外的定义一个参数类，会造成额外的工作，但是在现在IDE自动生成类框架的前提下，其实也没有太多的额外工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;其实无论是PHP还是其他语言，通过定义参数类或者是结构体进行参数传递，都是优于传递数组参数，更优于直接传过多的参数变量的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2017-03-17</pubDate>  
    </item>  
    <item>  
		<title>phpstorm配置xdebug调试</title>  
		<link>http://daimin.github.io//posts/phpstorm-peizhi-xdebug-tiaoshi.html</link>  
		<description>&lt;h1&gt;phpstorm配置xdebug调试&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安装xdebug，记得xdebug的版本和php的版本一致。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置php.ini中关于xdebug的配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[xdebug]
zend_extension=&#34;Your xdebug install path&#34;
xdebug.remote_enable = On
xdebug.remote_handler = dbgp   
xdebug.remote_host= localhost
xdebug.remote_port = 9000
xdebug.idekey = PHPSTORM
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中remote_host 是指调试客户端的地址，即IDE所在的IP，同理remote_port 是客户端的端口，这两项在远程调试的情况下注意修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开phpStorm，进入File&amp;gt;Settings&amp;gt;PHP&amp;gt;Servers。 这里要填写服务器端的相关信息，name填localhost，host填localhost，port填80，debugger选XDebug。这里设置的是将要进行xdebug调试的服务器地址。在这之前请设置好php解释器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;进入File&amp;gt;Settings&amp;gt;PHP&amp;gt;Debug，看到XDebug选项卡，port填9000，其他默认。这里的port地址是你在php.ini中xdebug配置中的&lt;code&gt;xdebug.remote_port&lt;/code&gt;的值。&lt;/li&gt;
&lt;li&gt;进入File&amp;gt;Settings&amp;gt;PHP&amp;gt;Debug&amp;gt;DBGp Proxy，IDE key 填 PHPSTORM，host 填localhost，port 填80。这里的IDE KEY是你在php.ini中xdebug配置中的&lt;code&gt;xdebug.idekey&lt;/code&gt;的值。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Run&amp;gt;Debug/Run Configurations 中设置Debug配置，如下图: 
               &lt;img alt=&#34;http://77g0dq.com1.z0.glb.clouddn.com/5F6B6D94-270D-459E-BDF9-802364F6942F.png&#34; src=&#34;http://77g0dq.com1.z0.glb.clouddn.com/5F6B6D94-270D-459E-BDF9-802364F6942F.png&#34; /&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在代码中需要调试处，加上断点，然后在Run菜单中运行你配置的App。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-08-07</pubDate>  
    </item>  
    <item>  
		<title>mac上docker的安装和简单使用</title>  
		<link>http://daimin.github.io//posts/docker-anzhuang-shiyong.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;本来在centos上面安装docker，本来都成功了，但是运行不起来，发生如下错误：
&lt;code&gt;FATA[0000] inappropriate ioctl for device&lt;/code&gt;，应该是内核版本太低，想升级内核，结果发现使用的vps无法升级内核，无奈只能在mbp上面安装了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装boot2docker，官网网速太慢，在百度网盘上面找了一个1.4.1版本的，速度飞快，链接在&lt;a href=&#34;http://pan.baidu.com/s/1eQxouwa&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装好boot2docker，然后执行&lt;code&gt;boot2docker init&lt;/code&gt;就行，初始化启动成功后，使用&lt;code&gt;boot2docker ssh&lt;/code&gt;进入虚拟机(boot2docker采用virualbox)，可以在virualbox看到我们启动的主机。&lt;code&gt;export DOCKER_HOST=tcp://$(boot2docker ip 2&amp;gt;/dev/null):2375&lt;/code&gt;在本机配置docker的host。&lt;/p&gt;
&lt;p&gt;Mac OS X -- boot2docker -- container 三者之间的关系
&lt;img alt=&#34;&#34; src=&#34;http://vaga-static.qiniudn.com/docker-install-800x417.png&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入虚拟机后其实docker已经启动了，如果没有执行&lt;code&gt;docker -d&lt;/code&gt;。执行&lt;code&gt;docker images&lt;/code&gt;会看到我们的docker镜像，如果没有，执行&lt;code&gt;docker pull learn/tutorial&lt;/code&gt;，这样会拉取一个教程性质的镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker镜像其实也是类似于虚拟机的沙盒环境，不过肯定更轻量级，而且性能损耗更少。类似于ubuntu环境，可以用 &lt;code&gt;apt-get install&lt;/code&gt; 来安装软件。&lt;code&gt;docker run learn/tutorial echo hello world&lt;/code&gt;在指定的image上执行命令，不过这个是没有交互的，比如在镜像安装软件必须&lt;code&gt;docker run learn/tutorial apt-get install ping -y&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以直接进入docker镜像命令行，&lt;code&gt;docker run -i -t  learn/tutorial  sh&lt;/code&gt;(其实就是在镜像中运行sh命令而已)。在docker安装服务器上执行&lt;code&gt;docker ps&lt;/code&gt;可以看到运行的实例(容器)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker search ubuntu&lt;/code&gt; 查询于ubuntu相关的镜像，也可以查询其它的镜像，如：&lt;code&gt;docker search centos&lt;/code&gt;等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在运行该镜像的容器中安装了软件，需要把新的内容保存到该镜像中去，否则下次启动该镜像又恢复成原样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uqiu@localhost ~&amp;gt; docker ps -l
CONTAINER ID        IMAGE                   COMMAND             CREATED             STATUS              PORTS               NAMES
95903c1a2bf7        learn/tutorial:latest   /bin/bash           6 minutes ago       Up 5 minutes        80/tcp              thirsty_colden
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到容器的 ID，然后执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker commit 95903c1a2bf7 learn/tutorial:latest&lt;/code&gt;  #把当前容器的修改提交到镜像 learn/tutorial  中去。记住要在退出之前提交。镜像名其实是可以指定为其它名称的，只是下次进来时，需要使用修改后的镜像名才能进入最近的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查容器的运行信息，&lt;code&gt;docker inspect 0911&lt;/code&gt;，最后的参数是容器的id前4位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker push learn/ping&lt;/code&gt;，发布自己的镜像，learn/ping是镜像名。前提是在&lt;a href=&#34;https://hub.docker.com/&#34;&gt;https://hub.docker.com/&lt;/a&gt;注册自己的帐号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口映射&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;boot2docker ssh -L 50080:localhost:40080  #这条命令可以在  boot2docker-vm  运行时执行，建立多个不同的映射就是执行多次，映射本机的50080到vm的40080

docker run -i -t -p 40080:80 learn/tutorial bash # 映射vm的40080到learn/tutorial容器的80端口。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ssh映射&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;docker容器中安装ssh服务，并启动。commit后退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boot2docker ssh -L 50080:localhost:40080 -L 50443:localhost:40443 -L50022:localhost:40022&lt;/code&gt;，映射多个ip到localhost，并启动vm。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;docker run -i -t -p 40080:80 -p 40443:443 -p 40022:22 daimin/test bash&lt;/code&gt;，映射端口方式启动docker容器，这个时候40022映射到了容器的22端口，也就是ssh端口，然后开启ssh服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在控制台输入&lt;code&gt;ssh -p 50022 root@localhost&lt;/code&gt;，发现提示输入用户密码，然后成功登录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用Dockerfile制作我们的image&lt;/p&gt;
&lt;p&gt;编写Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# sshd
#
# VERSION 0.0.1

FROM centos:latest
MAINTAINER Dai Min &#34;daimin@mama.cn&#34;

# make sure the package respository is up to date
RUN yum clean all
RUN yum install -y openssh-server   # 安装ssh服务端
RUN sed -i &#39;s/PasswordAuthentication no/PasswordAuthentication yes/g&#39; /etc/ssh/sshd_config # 修改sshd_config文件为密码登录，当然你可以自己修改为公钥登录
RUN sed -i &#39;s/PubkeyAuthentication yes/PubkeyAuthentication no/g&#39; /etc/ssh/sshd_config  # 关闭公钥登录
RUN sed -i &#39;s/UsePAM yes/UsePAM no/g&#39; /etc/ssh/sshd_config # 必须要关闭，否则登录后马上掉线

RUN mkdir /var/run/sshd  # ssh运行目录
RUN echo &#34;root:123&#34; | chpasswd  # 修改root密码

# 下面这两句比较特殊，在centos6上必须要有，否则创建出来的容器sshd不能登录  
RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key

# Expose port 22 from the container to the host
EXPOSE 22
CMD [&#34;/usr/sbin/sshd&#34;, &#34;-D&#34;]  # 运行ssh服务
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后进入到Dockerfile所在目录，执行&lt;code&gt;docker build -t eg_sshd .&lt;/code&gt;，等待命令成功，&lt;code&gt;docker run -d -P --name=mytest eg_ssh&lt;/code&gt;，在后台运行容器。&lt;/p&gt;
&lt;p&gt;然后用&lt;code&gt;sudo docker inspect mytest&lt;/code&gt;查看容器信息，找到ip，如果容器ip连接不了，就使用其映射到的本机ip，如 &lt;code&gt;ssh -p 40022 root@127.0.0.1&lt;/code&gt;，发现可以登录了。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-04-01</pubDate>  
    </item>  
    <item>  
		<title>在iTerm2中的vim使用solarized配色</title>  
		<link>http://daimin.github.io//posts/iterm2-vim-solarized-shiyong.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;一直很心水solarized主题，可是在iTerm2中vim无法正常的使用，会有一层朦朦的背景色，在macvim到是可以，但是主要还是使用iTerm2的vim。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;折腾了很久，按照网上的方案一直不行，最后在&lt;a href=&#34;https://github.com/altercation/solarized/tree/master/iterm2-colors-solarized&#34;&gt;https://github.com/altercation/solarized/tree/master/iterm2-colors-solarized&lt;/a&gt;找到了方法：&lt;/p&gt;
&lt;p&gt;这个目录下有两个iTerm2的solarized配色方案，我是用的dark的。
然后如下：&lt;/p&gt;
&lt;p&gt;Open iTerm 2, open Preferences, click on the &#34;Profiles&#34; (formerly Addresses, formerly Bookmarks) icon in the preferences toolbar, then select the &#34;colors&#34; tab. Click on the &#34;load presets&#34; and select &#34;import...&#34;. Select the Solarized Light or Dark theme file.&lt;/p&gt;
&lt;p&gt;You have now loaded the Solarized color presets into iTerm 2, but haven&#39;t yet applied them. To apply them, simply select an existing profile from the profile list window on the left, or create a new profile. Then select the Solarized Dark or Solarized Light preset from the &#34;Load Presets&#34; drop down.&lt;/p&gt;
&lt;p&gt;简单来说就是在iTerm2的Profiles edit中，选择colors tab，然后点击&#34;load presets&#34;，就可以加载你下载的配置方案了。&lt;/p&gt;
&lt;p&gt;然后在当前的profile中在&#34;load presets&#34;下拉列表中选择刚刚load的配色方案，你会发现你的整个iterm2界面都成了solarized了。&lt;/p&gt;
&lt;p&gt;最后可以再profile列表中的，&#34;Other Actions&#34;下拉列表中选择&#34;Bulk Copy from Selected Profile&#34;，将当前的colors方案拷贝到其它profile中，这样你所有的profile的iTerm2界面都是solarized了。&lt;/p&gt;
&lt;p&gt;最后回到vim，修改~/.vimrc，加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set background=dark
colo solarized
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok，发现vim的solarized也正常使用了。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-03-26</pubDate>  
    </item>  
    <item>  
		<title>django和celery简单结合使用</title>  
		<link>http://daimin.github.io//posts/django-celery-jihe-shiyong.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;自行安装django,celery,flower,rabbitmq,mysql &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建django项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;django-admin.py startproject djangoxs
cd djangoxs
python manage.py startapp xs
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改settings.py      &lt;br /&gt;
    进入djangoxs目录&lt;code&gt;cd djangoxs&lt;/code&gt;，这个是工程目录。
    settings.py是整个工程的配置文件，主要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 设置静态文件根目录(js/css/images)，务必绝对路径
import os
STATIC_ROOT = os.path.realpath(os.path.join(conf.ROOT_DIR, &#39;../static/&#39;))
# 静态文件的url前缀
STATIC_URL = &#39;/static/&#39;
# 静态文件url及相应的文件目录配置
STATICFILES_DIRS = (
    (&#34;css&#34;, os.path.join(STATIC_ROOT, &#39;css&#39;)),
    (&#34;js&#34;, os.path.join(STATIC_ROOT, &#39;js&#39;)),
    (&#34;images&#34;, os.path.join(STATIC_ROOT, &#39;images&#39;)),
    (&#34;admin/css&#34;, os.path.join(STATIC_ROOT, &#39;admin/css&#39;)),
)
# 静态文件发现器，安装排序优先级
STATICFILES_FINDERS = (
    &#39;django.contrib.staticfiles.finders.FileSystemFinder&#39;, # 文件系统
    &#39;django.contrib.staticfiles.finders.AppDirectoriesFinder&#39;, # app目录
)
# 模板的路径
TEMPLATE_DIRS = (
    os.path.join(ROOT_DIR, &#39;templates/&#39;),
)
# 模板加载器，按优先级排序
TEMPLATE_LOADERS = (
    &#39;django.template.loaders.filesystem.Loader&#39;,  # 从TEMPLATE_DIRS加载template
    &#39;django.template.loaders.app_directories.Loader&#39;, # 从app目录下载
)

# celery的配置，需要安装django-celery
import celeryconfig
import djcelery
djcelery.setup_loader()
# broker的url，即rabbitmq的url
BROKER_URL = celeryconfig.BROKER_URL
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用supervisor来监控各个进程，这里是flower和celery，记住要配置环境变量DJANGO_SETTINGS_MODULE，这里暂时只监控了flower和celery，其实各个都可以加入监控的。另外要注意的django的celery不是普通的启动方式来启动的worker而是使用manaer.py，可参见下面的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[program:flower]
environment=DJANGO_SETTINGS_MODULE=&#39;djangoxs.settings&#39;
user = root
directory = /data/pywork/djangoxs/
command = /usr/local/python27/bin/python manage.py celery flower --loglevel=info
process_name = %(program_name)s
numprocs=1
stdout_logfile = /home/logs/flower.stdout.log
stderr_logfile = /home/logs/flower.stderr.log
redirect_stderr = true
autostart = true
autorestart = true

[program:celery_worker]
environment=DJANGO_SETTINGS_MODULE=&#39;djangoxs.settings&#39;
user = root
directory = /data/pywork/djangoxs/
command = /usr/local/python27/bin/python manage.py celery worker --loglevel=info
process_name = %(program_name)s
numprocs=1
stdout_logfile = /home/logs/celery.xs.stdout.log
stderr_logfile = /home/logs/celery.xs.stderr.log
redirect_stderr = true
autostart = true
autorestart = true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;app的模板直接放在app下面就行了，模板名和model名一样就可以自动加载。
   需要注意admin的模板，可以从系统源码中拷贝过来放在工程目录的templates下，在这里就是djangoxs/djangoxs/templates/admin/下面，如果需要自定义模板可以根据 admin/appname/modelname/来放置模板，change_list.html代表列表，change_form代表表单，如此类推...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;model的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;verbose_name代表field的表示名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__unicode__&lt;/code&gt;函数返回值为model类的表示名称，比如print model时，返回这个值。&lt;/li&gt;
&lt;li&gt;Meta定义了model类的元信息，verbose_name_plural为后台展示名称,app_label为app名称，model_name为模块名称，等等，需要注意如果要在model中访问meta，需要用self._meta。&lt;/li&gt;
&lt;li&gt;ImageField的upload_to参数为图片上次目录,DateTimeField的auto_now为自动填充当前时间，BooleanField的choices参数为二维元组，代表可以选择值及其说明。&lt;/li&gt;
&lt;li&gt;ForeigKey(xxx)xxx为外键所在类&lt;/li&gt;
&lt;li&gt;在model中定义的函数，也可以当做model的field，只是不会映射为数据项。allow_tags表示允许包含html标签。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以通过重写django的组件达到更多的功能，比如重写admin.widgets.AdminTextWidget来修改admin的默认的Textarea控件的行数和列数。然后在ModelAdmin中formfield_overrides中覆盖原有field。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class HighTextarea(admin.widgets.AdminTextareaWidget):
    def __init__(self, attrs=None):
        default_attrs = {&#39;cols&#39;: &#39;80&#39;, &#39;rows&#39;: &#39;30&#39;}
        if attrs:
            default_attrs.update(attrs)
        super(HighTextarea, self).__init__(default_attrs)

class AdminChapter(admin.ModelAdmin):

    formfield_overrides = {
        models.TextField : {&#39;widget&#39;: HighTextarea}
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;admin中list_per_page表示每页多少行，list_max_show_all表示点击显示所有后最多显示的行数。用django.utils.html.format_html来在代码中输出html，否则都是转义后的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;admin的list_display中的元素可以是model的field，也可是model中的函数，也可以是ModelAdmin中的函数，这个函数的第一个参数为当前model对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;admin中的raw_id_fields用于外键，用来生成一个弹窗选择外键所对应的model对象。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-03-20</pubDate>  
    </item>  
    <item>  
		<title>计算机基础知识</title>  
		<link>http://daimin.github.io//posts/jisuanji-jichu-zhishi.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;计算下100的反码是多少？&lt;pre&gt;&lt;code&gt;首先100的二机制是01100100，它的反码是10011011，因为是有符号的，那么这个数表示为：因为最高位是1，那么肯定是负数，将该数取反就是100，即01100100，然后负数要+1，也就是101，那么10011011也就是-101。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-03-13</pubDate>  
    </item>  
    <item>  
		<title>python协程使用</title>  
		<link>http://daimin.github.io//posts/pythono-xie-cheng-shi-yong.html</link>  
		<description>&lt;p&gt;协程是一种比线程更轻量级的执行体。它不是有系统内核控制调度，而是自己协同调度。Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from gevent import monkey
# 由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey
monkey.patch_socket()
import gevent

def f(n):
    for i in range(n):
        print gevent.getcurrent(), i
        gevent.sleep(0) # 要想协程起作用，可以通过gevent.sleep()交出控制权


g1 = gevent.spawn(f, 5)
g2 = gevent.spawn(f, 5)
g3 = gevent.spawn(f, 5)

g1.join()
g2.join()
g3.join()

output:
&amp;lt;Greenlet at 0x10bc44c30: f(5)&amp;gt; 0
&amp;lt;Greenlet at 0x10bd600f0: f(5)&amp;gt; 0
&amp;lt;Greenlet at 0x10bd60190: f(5)&amp;gt; 0
&amp;lt;Greenlet at 0x10bc44c30: f(5)&amp;gt; 1
&amp;lt;Greenlet at 0x10bd600f0: f(5)&amp;gt; 1
&amp;lt;Greenlet at 0x10bd60190: f(5)&amp;gt; 1
&amp;lt;Greenlet at 0x10bc44c30: f(5)&amp;gt; 2
&amp;lt;Greenlet at 0x10bd600f0: f(5)&amp;gt; 2
&amp;lt;Greenlet at 0x10bd60190: f(5)&amp;gt; 2
&amp;lt;Greenlet at 0x10bc44c30: f(5)&amp;gt; 3
&amp;lt;Greenlet at 0x10bd600f0: f(5)&amp;gt; 3
&amp;lt;Greenlet at 0x10bd60190: f(5)&amp;gt; 3
&amp;lt;Greenlet at 0x10bc44c30: f(5)&amp;gt; 4
&amp;lt;Greenlet at 0x10bd600f0: f(5)&amp;gt; 4
&amp;lt;Greenlet at 0x10bd60190: f(5)&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到协程的交替运行了。&lt;/p&gt;
&lt;p&gt;在实际的使用中，我们不需要使用gevent.sleep去控制，而是在遇到io时候，gevent会自动控制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from gevent import monkey
# 由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey
monkey.patch_socket()
import gevent
import urllib2

def f(url):
    print &#39;GET: %s&#39; % url
    resp = urllib2.urlopen(url)
    data = resp.read()
    print &#39;%d bytes received from %s.&#39; % (len(data), url)


gevent.joinall([
    gevent.spawn(f, &#39;http://www.baidu.com/&#39;),
    gevent.spawn(f, &#39;http://www.taobao.com/&#39;),
    gevent.spawn(f, &#39;http://www.163.com/&#39;),
])

output:
GET: http://www.baidu.com/
GET: http://www.taobao.com/
GET: http://www.163.com/
46944 bytes received from http://www.taobao.com/.
88998 bytes received from http://www.baidu.com/.
662118 bytes received from http://www.163.com/.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出在同一个进程中执行，但是顺序却不同了，可见网络io的时候是并发执行的。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-03-10</pubDate>  
    </item>  
    <item>  
		<title>走过2014</title>  
		<link>http://daimin.github.io//posts/zou-guo-2014.html</link>  
		<description>&lt;p&gt;2014年就这么安静的过去，很平淡，却让我比较舒服。  &lt;/p&gt;
&lt;p&gt;2014年春节的时候换了一家公司，其实不是换，因为上家公司解散了，去年就面好了现在这家公司，于是年后换了房子后就直接来上班了。&lt;/p&gt;
&lt;p&gt;现公司是一家才开始发展的公司，制度有些不成熟，有些不大气，不过有一点还好就是比较自由，其实就是大家都没有什么事情干，做好手上那么一丁点的事情就可以自己学习感兴趣的了。在这里感觉还是有很大的进步，对自己以后的职业发展还是比较有信心了，但我却觉得到了我该离开的时候了，过完年后吧。&lt;/p&gt;
&lt;p&gt;今年最大的一件事情，就是结婚了，拍婚纱照，准备婚礼，包括结婚那天，其实很忙很累，却非常的高兴，是啊！和心爱的人儿步入婚姻，相许今生，这世上还有什么比这更值得高兴而幸福的事情了呢？&lt;/p&gt;
&lt;p&gt;然后就是回来广州上班了，生活比较平静，工作也比较安逸，我却知道我要再去折腾一下，为爱人，为家人，为以后的孩子，也是为自己。&lt;/p&gt;
&lt;p&gt;2015的打算？换个工作，称心如意，不是很忙，不是很闲，不是很简单，也不是很廉价。我最想的，也是老婆、父母最想的就是孩子，多少次，都在想那个可爱的小家伙，什么时候会来到我们身边呢？&lt;/p&gt;
&lt;p&gt;一直觉得，能够生活的平平淡淡，简简单单，身体健健康康，和心爱的人一起把孩子带大，照顾好双方的父母。等我们在外面做不动了就回到家乡，安静的生活，有时候出去旅游一下，养养鸡鸭，或是去地里劳作下，或是再敲敲自己喜欢的代码。如果这是我们的一辈子，该是多么幸福的事情啊！&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2015-01-01</pubDate>  
    </item>  
    <item>  
		<title>大数据处理的一些算法学习</title>  
		<link>http://daimin.github.io//posts/da-shu-ju-chu-li-de-yi-xie-suan-fa-xue-xi.html</link>  
		<description>&lt;p&gt;一、 倒排索引
一般的索引都是通过在内容中提取关键词作为索引，索引文件记录每个文章中出现的关键词，查询的时候根据搜索内容去查询每个文档的关键词，来确定是否为所需文档，然后合并查询结果。（以文档为中心）
倒排索引是通过关键词去存储相关的文档地址和频度(出现次数)，通过搜索词分词去查询关键字，然后得到关键词对应的文档地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。（以关键词为中心）&lt;/p&gt;
&lt;p&gt;二、bloomfilter&lt;/p&gt;
&lt;p&gt;两个不同url通过同一个hash可能得到相同的值(hash碰撞)
特性：bloomfilter不存在的肯定不存在，bloomfilter中存在的可能判断为不存在。不会漏，只会错
主要就是两个函数，求bitarray的大小的：m = ceil((n * ln(p)) / ln(1.0 / (pow(2.0, ln(2.0)))))；求hash函数的个数：k=(ln2)*(m/n)
bloomfilter 可以看做是bitmap的扩展
bitmap一般采用bit位置表示值，而1或0表示是否存在该值&lt;/p&gt;
&lt;p&gt;三、外排序
     1. 外排序其实就是内存不够用的时候，在外存储器（一般是硬盘）暂时存储排序数据的方式。
     2. 比如有一个文件很大，需要对其中的数据进行排序，而其容量大概是内存的10倍，这样&lt;/p&gt;
&lt;p&gt;四、trie树
     1. 将词语的每个字符作为节点构建树，算法十分简单
     2. 从root开始到叶子节点的路径，每一条都是一个词语
     3. 时间复杂度大概是O(N)，由于公共前缀会使用相同的路径，所以也节省了大量的空间，如果词语存在的公共前缀越多会越省空间（持久化的时候会比原文件小很多）。
但是由于每一个字符都会使用一个节点，对应一个变量空间，所以对于直接存储字符串，会浪费更多内存。支持字符集的N次方(N为词语长度)
     4. 我这里python版本的，使用dict嵌套完成，并不会存在以上的字符集N次方的问题，dict自动增长，默认支持所有的字符集，一般来讲会比原词语集占内存较少，只是保存dict结构需要浪费额外的内存。&lt;/p&gt;
&lt;p&gt;五、双层桶划分
     1. 其实就是一种思想，就是当数据量过大，内存处理不过来时，将数据分割成内存可以处理的大小，然后分步处理，可以经过多次划分处理，直到内存可以合并最后的处理数据。
     2. 其实可以知外排序也是双层桶划分的一种体现。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-12-30</pubDate>  
    </item>  
    <item>  
		<title>celery的使用</title>  
		<link>http://daimin.github.io//posts/celery-shi-yong.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;celery首推的队列就是rabbitmq&lt;/p&gt;
&lt;p&gt;mac下：
   &lt;code&gt;brew install rabbitmq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;linux:
  &lt;code&gt;sudo apt-get install rabbitmq-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;celery，直接pip install celery就行了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;task&lt;pre&gt;&lt;code&gt;from celery import Celery
app = Celery(&#39;tasks&#39;, broker=&#39;amqp://guest@localhost//&#39;)

@app.task
def add(x, y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在同级目录运行&lt;code&gt;$ celery -A tasks worker --loglevel=info&lt;/code&gt; 启动一个worker。并将add加入的任务队列中。&lt;/p&gt;
&lt;p&gt;在当前目录重新打开一个python命令行窗口，输入：   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;gt;&amp;gt;&amp;gt; from tasks import add
    &amp;gt;&amp;gt;&amp;gt; add.delay(4, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具有backend的worker(一般没必要)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    from time import sleep
    from celery import Celery

    backend = &#34;db+mysql://root:123@127.0.0.1/celery&#34;
    broker=&#39;amqp://guest@localhost//&#39;
    app = Celery(&#39;tasks&#39;, backend=backend, broker=broker)

    @app.task
    def add(x, y):
        sleep(10)
        return x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样运行结构就会写入的mysql中了，这里需要安装SQLAlchemy。&lt;/p&gt;
&lt;p&gt;delay是Task.apply_async的快捷函数，表示异步执行，这样会得到celery的最好控制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法1  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from celery import Celery

app = Celery()
import celeryconfig
app.config_from_object(celeryconfig)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Config:
    CELERY_ENABLE_UTC = True
    CELERY_TIMEZONE = &#39;Europe/London&#39;

app.config_from_object(Config)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有好几种方法...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flower&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;celery监控工具，直接&lt;code&gt;pip install flower&lt;/code&gt;就行了，然后运行flower命令，就可以查看celery的运行清空。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;celery作为异步队列一般不需要太关心执行的结果，可&lt;code&gt;@app.task(ignore_result=True)&lt;/code&gt;忽略结果，也可以在config中设置&lt;code&gt;CELERY_IGNORE_RESULT=True&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;default_retry_delay=300, max_retries=5可以设置重试的时隔和最多次数，retry机制也是celery可靠的特点。&lt;/li&gt;
&lt;li&gt;可以通过设置具有优先级的worker来决定那些任务需要优先执行。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-08-28</pubDate>  
    </item>  
    <item>  
		<title>使用VirtualBox使centos和win7共享文件夹设置</title>  
		<link>http://daimin.github.io//posts/virtualbox-share-dir.html</link>  
		<description>&lt;p&gt;简单的记录一下。&lt;/p&gt;
&lt;p&gt;VirtualBox非常好用比vmware好用多了。它的VirtualBox功能，可以让我们直接在windows上面开发代码，而在虚拟机下面运行，这为像我这样不是很熟悉linux开发工具的很受力。&lt;/p&gt;
&lt;p&gt;首先共享文件夹，需要安装增强工具包。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运行centos虚拟机，打开设备菜单中点击安装增强功能，悬浮鼠标在右下角的光盘图标上，可以看到当前光盘中是VBoxGuestAdditions.iso，这个是安装增强功能的镜像文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入centos，在/media下面mkdir cdrom，然后执行&lt;code&gt;mount -t iso9660 /dev/cdrom /media/cdrom&lt;/code&gt;，挂载光驱到文件系统，打开/media/cdrom，这里可以看到&lt;code&gt;VBoxLinuxAdditions.run&lt;/code&gt;，这个是我们需要运行的文件，这里就可以安装增强工具了。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不过首先要安装&lt;code&gt;yum install kernel-devel kernel-headers&lt;/code&gt;以及&lt;code&gt;yum install gcc&lt;/code&gt;和&lt;code&gt;yum install make&lt;/code&gt;，这样安装了还是不行，需要链接一下安装的kernel库，&lt;code&gt;ln -s /usr/src/kernels/2.6.32-431.11.2.el6.x86_64/ /usr/src/linux&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后在挂载光驱中执行&lt;code&gt;./VBoxLinuxAdditions.run&lt;/code&gt;，等待完成就OK，这里可能有几个错误，不过没有关系，它主要是因为UI系统的功能没有安装成功，如果你没有安装x11的话。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OK，安装增强工具完成，开始设置共享文件夹。&lt;/p&gt;
&lt;p&gt;虚拟机的设备菜单中选择“共享文件夹”，添加固定分配的共享文件夹，选择需要共享到虚拟机的win7文件夹。设置完成后，进行centos，执行&lt;code&gt;mkdir /mnt/share&lt;/code&gt;，然后执行&lt;code&gt;mount -t vboxsf pywork /mnt/share&lt;/code&gt;，&lt;strong&gt;需要注意挂载文件夹名不要和共享文件夹名相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进行/mnt/share，执行&lt;code&gt;ls -l&lt;/code&gt;，可以看到win7的文件夹内容完全可以在linux下面访问了，而且可以直接用centos下面的命令，运行之。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-04-14</pubDate>  
    </item>  
    <item>  
		<title>安装scrapy</title>  
		<link>http://daimin.github.io//posts/an-zhuang-scrapy.html</link>  
		<description>&lt;p&gt;scrapy超级难装，它依赖很多库，反正我在windows上面没有装成功，linux上面弄了N久终于装好了，现在来记录一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要确保系统安装了如下的库，没有就执行安装。&lt;/p&gt;
&lt;p&gt;yum install gcc libffi-devel python-devel openssl-devel&lt;/p&gt;
&lt;p&gt;这里可能会失败，如果没有安装repo的key的话，你可以修改.repo文件，将其      &lt;strong&gt;gpgcheck=0&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装python，这个没什么好说的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Twisted，这个很简单。可是http://pypi.python.org在国内真的不稳定，而且好慢。所以你可以使用一下的镜像：&lt;/p&gt;
&lt;p&gt;推荐使用豆瓣的，真心速度不错。&lt;/p&gt;
&lt;p&gt;http://pypi.douban.com/  豆瓣&lt;br /&gt;
   http://pypi.hustunique.com/  华中理工大学&lt;br /&gt;
   http://pypi.sdutlinux.org/  山东理工大学&lt;br /&gt;
   http://pypi.mirrors.ustc.edu.cn/  中国科学技术大学  &lt;/p&gt;
&lt;p&gt;pip install Twisted -i http://pypi.douban.com/simple  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装w3lib&lt;br /&gt;
pip install w3lib -i http://pypi.douban.com/simple  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装lxml&lt;br /&gt;
pip install lxml -i http://pypi.douban.com/simple  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装scrapy，这里要注意cffi，在豆瓣上面是没有的，你可以去其他的地方找，pypi.python.org,或者github上面应该会有吧。前面第一步安装那几个devel库就是为了让这个能成功编译安装。安装scrapy就十分简单了：&lt;br /&gt;
pip install scrapy -i http://pypi.douban.com/simple&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;ok，好了，终于搞好了， &lt;br /&gt;
准备用这个弄一个图书网站，爬虫 + 搜索引擎 + 大数据存储。哈哈！  &lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-04-03</pubDate>  
    </item>  
    <item>  
		<title>coreseek(sphinx)分布式设置</title>  
		<link>http://daimin.github.io//posts/coreseek-distributed-config.html</link>  
		<description>&lt;p&gt;sphinx默认是单线程的，无论你是多少核的服务器，它始终只会使用一个核心。
有两个办法可以实现sphinx多核利用，两种都是使用sphinx的分布式设置。&lt;/p&gt;
&lt;h3&gt;1. 使用agent，远程索引声明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;建立一个分布式索引，这个索引不会用来存储数据，只是用来合并查询数据，提供客户端调用而已&lt;/li&gt;
&lt;li&gt;设置分布式索引的type=distributed&lt;/li&gt;
&lt;li&gt;将local属性指向自身就行，这里就是dist&lt;/li&gt;
&lt;li&gt;agent执行独立运行的searchd进程，可以是本机的，也可以在其它机器上面运行，不过注意的是agent的数据源必须相同，否则无法合并。&lt;/li&gt;
&lt;li&gt;agent的数据源是我们采用一定的算法将一个数据源拆分成积分，如id取模或者是其它方式。&lt;/li&gt;
&lt;li&gt;客户端进行搜索的时候就直接使用dist索引进程查询就行了。&lt;pre&gt;&lt;code&gt;index dist
{
    type = distributed
    local = chunk1
    agent = localhost:9312:chunk2
    agent = localhost:9312:chunk3
    agent = localhost:9312:chunk4
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 使用local，本地索引声明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;严格来说不算是分布式，只是多线程搜索&lt;/li&gt;
&lt;li&gt;coreseek4.1的手册上面明确的写着“全部本地索引会被依次搜索，仅使用1个CPU或核。”。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不过手册中没有翻译的文档中有一个dist_threads参数，这个参数指明并发查询现场数，里面写到，从sphinx-2.0.1-bata(coreseek4.1正是基于这个版本的sphinx)开始就可以使用了，它指明以多少个线程的方式去查询索引，线程数最好和索引数相同(不包括聚合索引，这里就是dist_test)。这里可以这样配置:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;index dist_test
{
    type = distributed
    local = chunk1
    local = chunk2
    local = chunk3
    local = chunk4
}

#...

dist_threads = 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里的chunk1 - chunk4正是我们配置的多个索引，需要在同一份配置文件中配置，它们的数据源也是和上文一样的方式从一个数据源中拆分出来的。
可以参考&lt;a href=&#34;http://www.oschina.net/translate/sphinx-search-performance-optimization-multi-threaded-search&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;coreseek4.1 基于sphinx-2.0.1-bata，其多线程查询支持可能并不完善，可能我们需要升级更高版本的sphinx才能更好的支持这一特性(我在虚拟机上面配置，似乎就没有启用多线程)。&lt;br /&gt;
而且基于数据源拆分实现的分布式，可能会有一些隐患，需要我们仔细分析。
如果想实现比较完美的分布式搜索引擎可能solr，elasticsearch这些为分布式而生的搜索引擎会更符合我们的需要。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-03-31</pubDate>  
    </item>  
    <item>  
		<title>使用elasticsearch搭建一个搜索系统</title>  
		<link>http://daimin.github.io//posts/elasticsearch-flask-pyes-da-jian-shi-yong.html</link>  
		<description>&lt;p&gt;要搭建一个日志分析系统，使用的elasticsearch+logstash+redis+kibana，搭建过程见之前的日志。&lt;/p&gt;
&lt;p&gt;elasticsearch是一个分布式的搜索引擎，基于lucene，但是我们不需要学习太多的lucene的知识，就能很方便的使用。&lt;/p&gt;
&lt;p&gt;它去中心化，会自动推举master，访问集群中的任何一个node，就是在和整个集群交互；添加节点只需要命名相同的集群名称，就能自动的加入。&lt;/p&gt;
&lt;p&gt;相比sphinx来说:&lt;br /&gt;
优点：&lt;br /&gt;
它是实时(一定程度上)的，非常容易实现分布式，能直接搜索出文档，而不是像sphinx一样要用id去数据库查询文档内容。elasticsearch其实就如同一个数据库一般使用。elasticsearch对中文分词的支持也要比sphinx要好些，而且提供了更新丰富的api实现各种搜索需求。elasticsearch可以自动对索引分片，提高建立索引的速度。&lt;br /&gt;
缺点:&lt;br /&gt;
比sphinx的检索速度要慢，建立索引的速度也要慢点(elasticsearch可以自动分片存储)，生成的索引文件很大，比源文档要大得多。elasticsearch内存大户。&lt;/p&gt;
&lt;p&gt;elasticsearch中文分词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以直接下载 &lt;a href=&#34;https://github.com/medcl/elasticsearch-rtf/&#34;&gt;elasticsearch-rtf&lt;/a&gt;，也可以进去下载你自己需要的插件。  可以参见&lt;a href=&#34;http://zhousheng29.iteye.com/blog/1849536&#34;&gt;这篇博文&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最新版本的elasticsearch使用mmseg插件时，可能会报错误，这是因为lunece4.6和mmseg插件不兼容，可以下载小于该版本的lucene来解决这个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pyes是python操作elasticsearch的工具库。从&lt;a href=&#34;https://github.com/aparo/pyes/&#34;&gt;github&lt;/a&gt;上下载就行，使用参见&lt;a href=&#34;http://pyes.readthedocs.org&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if self.__conn.indices.exists_index(self.__index_name):
    return
try:
    #删除索引
    self.__conn.indices.delete_index(self.__index_name)
except:
    pass
#创建索引
self.__conn.indices.create_index(self.__index_name)
mapping = {
       u&#39;date_added&#39;: {&#39;boost&#39;: 1.0,
                      &#39;index&#39;: &#39;not_analyzed&#39;,
                      &#39;store&#39;: &#39;yes&#39;,
                      &#39;type&#39;: u&#39;date&#39;},
       u&#39;title&#39;: {&#39;boost&#39;: 1.0,
                   &#39;index&#39;: &#39;analyzed&#39;,
                   &#39;store&#39;: &#39;yes&#39;,
                   &#39;type&#39;: u&#39;string&#39;,
                   &#34;indexAnalyzer&#34;:&#34;ik&#34;,
                   &#34;searchAnalyzer&#34;:&#34;ik&#34;,
                   },
       u&#39;content&#39;: {&#39;boost&#39;: 1.0,
                   &#39;index&#39;: &#39;analyzed&#39;,
                   &#39;store&#39;: &#39;yes&#39;,
                   &#39;type&#39;: u&#39;string&#39;,
                   &#34;indexAnalyzer&#34;:&#34;ik&#34;,
                   &#34;searchAnalyzer&#34;:&#34;ik&#34;,
                   &#34;term_vector&#34; : &#34;with_positions_offsets&#34;}
       }

#索引映射
self.__conn.indices.put_mapping(self.__index_type, {&#39;properties&#39;:mapping}, self.__index_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.__conn.index(data, self.__index_name, self.__index_type)
self.__conn.indices.refresh(self.__index_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#q = StringQuery(qstr) #会查询所有字段，并自动对关键字分词

#q = WildcardQuery(&#34;content&#34;, &#34;%s*&#34; % qstr) #通配符搜索
#q = q.search()
#q1 = TermQuery(&#34;title&#34;, qstr)  # 词条搜索，关键字不会分词
#q.add(&#34;content&#34;, qstr)

qtitle = TextQuery(&#34;title&#34;, qstr, boost=2) # 文本搜索，关键字会分词
qcontent = TextQuery(&#34;content&#34;, qstr, boost=1)
h = HighLighter([&#39;&amp;lt;span class=&#34;kw&#34;&amp;gt;&#39;], [&#39;&amp;lt;/span&amp;gt;&#39;], fragment_size=500) # 高亮
#q = FilteredQuery(MatchAllQuery(), q) 
#sort={&#39;date_added&#39;: {&#39;order&#39;: &#39;desc&#39;}}
# BooleanQuery，会根据must(AND)或should(OR)来对Query进行组合
# start起始，size获取大小
q = Search(BoolQuery(BoolQuery(should=[qtitle, qcontent])),highlight=h, start=0, size=50)
q.add_highlight(&#34;title&#34;)
q.add_highlight(&#34;content&#34;)

resultset = self.__conn.search(query=q, indices=self.__index_name,highlight=h, doc_types=[self.__index_type])
list=[]
for r in resultset:
    if r._meta.highlight.has_key(&#34;title&#34;):
        r[&#39;title&#39;] = r._meta.highlight[u&#34;title&#34;][0]
    if r._meta.highlight.has_key(&#34;content&#34;):
        r[&#39;content&#39;] = r._meta.highlight[u&#34;content&#34;][0]
    list.append(r)

return (list, resultset)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单的爬虫，用BeautifulSoup和正则表达式简单实现。数据直接存储在elasticsearch，只用sqlite保存URL的hash数据，以防重复抓取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if furl != self.__purl:
    hashfurl = self.md5(furl)
    if self.is_exist(hashfurl) :
        return
    else:
        self.__add_url(hashfurl)

time.sleep(0.5)
self.__logger.debug( &#34;========================= fetch and parse %s ========================\n&#34; % furl)

req = urllib2.Request(furl)
try:
    response = urllib2.urlopen(req)
    restext  = response.read()

    restext  = restext.decode(&#34;cp936&#34;).encode(&#34;UTF-8&#34;)
except:
    return
soup = BeautifulSoup(restext)
## 先拿文章
title = soup.find_all(id=&#34;h1title&#34;)
if title is not None and title &amp;lt;&amp;gt; []:
    title = title[0].get_text()

date_added = self.get_dateadded(soup)
print date_added

content = soup.find(id=&#34;endText&#34;)
if content is not None:
    content =  content.get_text()

if content is not None and date_added is not None and title is not None:
    self.save_new(title=title, content=content, date_added=date_added) 
else:
    self.__logger.warn( &#39;same attr is empty!!!!\n&#39;)


links = soup.find_all(&#34;a&#34;)

for link in links:
    href = link.get(&#34;href&#34;)
    #print href
    if href is not None:
        if self.__ptn.match(href):
            self.parse(str(href))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;记性不好，简单的记录。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-03-29</pubDate>  
    </item>  
    <item>  
		<title>用logstash+elasticsearch+Kibana+redis搭建实时日志查询、收集与分析平台(二)</title>  
		<link>http://daimin.github.io//posts/logstash-peizhi-shiyong-2.html</link>  
		<description>&lt;p&gt;最近又在整那个日志分析平台，之前由于服务器没到位，然后又其它任务要做，这里就搁置了，经理说这个还是要弄，下周就能给我个服务器，希望吧。&lt;/p&gt;
&lt;p&gt;最近弄elasticsearch集群部署，其实我的集群，就是virtualbox上面的两个系统（s1,s2），可怜啊，搞得电脑慢死了。&lt;/p&gt;
&lt;p&gt;elasticsearch是去中心化的，多个节点中哪台先起来，哪台就是master，如果master挂了，其它有成为master资格的节点中的一个就会成为master，这个由elasticsearch系统自己调配。&lt;/p&gt;
&lt;p&gt;elasticsearch会将索引分片存储在不同的节点上，形成分布式搜索。&lt;/p&gt;
&lt;p&gt;elasticsearch局域网集群设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各个节点要设置相同的&lt;code&gt;cluster.name: elasticsearch&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;不同的&lt;code&gt;node.name: &#34;Franz Kafka&#34;&lt;/code&gt;，&lt;code&gt;node.master: true&lt;/code&gt;设置节点是否有成为master节点的资格；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node.data: true&lt;/code&gt;指定该节点是否存储数据；&lt;/li&gt;
&lt;li&gt;禁止广播侦测：&lt;code&gt;discovery.zen.ping.multicast.enabled: false&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;设置可以成为master的节点地址：&lt;code&gt;discovery.zen.ping.unicast.hosts: [&#34;192.168.56.101&#34;]&lt;/code&gt;，这样当有新的节点加入的时候就能通过master就发现了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启动各个节点的elasticsearch。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;logstash的elasticsearch的设置，主要是indexer中的output的设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elasticsearch {
       protocol =&amp;gt; &#34;transport&#34;
       embedded =&amp;gt; false
       host =&amp;gt; &#34;192.168.56.101&#34;
       port =&amp;gt; &#34;9300&#34;
       cluster =&amp;gt; &#34;logstash_cluster&#34;
       #node_name =&amp;gt; &#34;es_master&#34;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;protocol表示logstash采用何种方式和elasticsearch交互。&lt;br /&gt;
protocol有三种类型：node、transport、http。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node会将自己作为一个elasticsearch节点加入集群，不过该节点只负责交互不存储数据；  &lt;/li&gt;
&lt;li&gt;transport就不会将自己作为一个node，而是直接使用集群中现有的节点；  &lt;/li&gt;
&lt;li&gt;http类型就是使用REST/HTTP去交互。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不填写protocol，jruby默认是node方式，而ruby环境默认是http。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我使用node类型一直不成功，从节点一直提示找不到logstash新加入的节点，各位有谁知道的麻烦告知一下。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-03-26</pubDate>  
    </item>  
    <item>  
		<title>php-resque的安装和使用</title>  
		<link>http://daimin.github.io//posts/php-resque-shiyong.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;Resque 是 Github 基于 Redis 开发的 background job 系统。PHP-Resque 是把 Resque porting 到 PHP 的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;redis的安装和运行就不多说，安装后运行就行了。&lt;/p&gt;
&lt;p&gt;从github中下载php-redis,&lt;a href=&#34;https://github.com/chrisboulton/php-resque&#34;&gt;https://github.com/chrisboulton/php-resque&lt;/a&gt;。加压后进入解压目录。&lt;/p&gt;
&lt;p&gt;安装Composer：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install curl
cd /usr/local/bin
curl -s http://getcomposer.org/installer | php
chmod a+x composer.phar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放置composer.phar到php-resque的安装目录，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;php composer.phar install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会提示失败，是因为没有安装phpunit，执行如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://phar.phpunit.de/phpunit.phar
chmod +x phpunit.phar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后也是在php-resque目录中执行php phpunit.phar，应该会成功。&lt;/p&gt;
&lt;p&gt;如果都成功的话，就安装好了php-resque了，接下来可以运行demo中的代码。&lt;/p&gt;
&lt;p&gt;demo/job.php是一个简单的job:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class PHP_Job
{
  // 每个Job都有这个方法，worker就是调用这个方法的。
    public function perform()
    {
        fwrite(STDOUT, &#39;Start job! -&amp;gt; &#39;);
        sleep(1);
        fwrite(STDOUT, &#39;Job ended!&#39; . PHP_EOL);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;demo/queue.php是一个队列插入示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
if(empty($argv[1])) {
    die(&#39;Specify the name of a job to add. e.g, php queue.php PHP_Job&#39;);
}

require __DIR__ . &#39;/init.php&#39;;
date_default_timezone_set(&#39;Asia/Shanghai&#39;);
//设置后台存储
Resque::setBackend(&#39;127.0.0.1:6379&#39;);
// job的参数
$args = array(
    &#39;time&#39; =&amp;gt; time(),
    &#39;array&#39; =&amp;gt; array(
        &#39;test&#39; =&amp;gt; &#39;test&#39;,
    ),
);

//添加队列和job
$jobId = Resque::enqueue($argv[1], $argv[2], $args, true);
echo &#34;Queued job &#34;.$jobId.&#34;\n\n&#34;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令行输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;php demo/queue.php default PHP_Job
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;demo/check_status.php 是检查job的执行情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;php demo/check_status.php jobid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;worker的一个实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

date_default_timezone_set(&#39;Asia/Shanghai&#39;);
require  __DIR__.&#39;/../../job.php&#39;;

require __DIR__.&#39;/../bin/resque&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里要require 包含job代码的文件，如果该文件中没有队列中指定的job名的类(定义了perform的类)，job将执行失败。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本就是这样，我简单的记录一下，记忆力不好，怕忘了。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-03-13</pubDate>  
    </item>  
    <item>  
		<title>用logstash+elasticsearch+Kibana+redis搭建实时日志查询、收集与分析平台</title>  
		<link>http://daimin.github.io//posts/logstash-peizhi-shiyong.html</link>  
		<description>&lt;p&gt;hadoop之类的是高帅富用的，我们用不过来。这里搭建一个简单的日志平台。&lt;/p&gt;
&lt;p&gt;logstash是一个管理日志和事件的工具，你可以收集它们，解析它们，并存储它们以供以后使用(例如日志搜索)，logstash有一个内置的web界面，用来搜索你的所有日志。logstash在部署时有两种运行模式：standalone和centralized：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;standalone：standalone的意思是所有的事情都在一台服务器上运行，包括日志收集、日志索引、前端WEB界面都部署在一台机器上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;centralized：就是多服务器模式，从很多服务器运输(ship)日志到一台总的日志(collector)服务器上用来索引和查找。&lt;/p&gt;
&lt;p&gt;需要注意的是logstash本身并没有什么shipper和collector这种说法，因为不论是运输日志的进程还是汇集总的日志的进程运行的都是同一个程序，只是使用的配置文件不同而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;这里部署centralized模式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;准备两台机器：server1 (192.168.56.102)，server2(192.168.56.101)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server1和server2中都安装JDK6以上版本，并配置JAVA环境变量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/data/softwares/jdk1.6.0_45
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/*.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server1上面运行logstash shipper和redis，用来收集日志，其实server1可以是多台生产服务器，我们做的就是监控这些服务器的日志。server2是日志分析服务器，安装logstash indexer和elasticsearch以及Kibana。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server1安装redis，直接yum install redis就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server1安装logstash，&lt;code&gt;wget https://download.elasticsearch.org/logstash/logstash/logstash-1.3.3-flatjar.jar&lt;/code&gt;，这个包很大，因为Kibana集成到里面了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server1运行redis-server，运行redis数据库，编写shipper:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
   file {
      type =&amp;gt; &#34;syslog&#34;
      path =&amp;gt; [&#34;/var/log/messages&#34;, &#34;/var/log/lastlog&#34;, &#34;/var/log/*.log&#34;]
   }

   file {
       type =&amp;gt; &#34;nginx-access&#34;
       path =&amp;gt; &#34;/var/log/nginx/access.log&#34;
   }
}

output {
    redis {
        host =&amp;gt; &#34;192.168.56.102&#34;
        port =&amp;gt; 6379
        data_type =&amp;gt; &#34;list&#34;
        key =&amp;gt; &#34;logstash&#34;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存为shipper.conf，然后执行&lt;code&gt;java -jar logstash-1.3.3-flatjar.jar agent -f shipper.conf&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将logstash从server1拷贝到server2中，并下载elasticsearch，&lt;code&gt;wget &#39;https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-0.90.7.tar.gz&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装elasticsearch，解压后，直接运行$elasticsearch_root/bin/elasticsearch -f，等待运行成功，注意其中的&lt;strong&gt;publish_address&lt;/strong&gt;为之后在indexer.conf中output中配置的端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行indexer，编写indexer.conf:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;input {
  redis {
    host =&amp;gt; &#34;192.168.56.102&#34;
    port =&amp;gt; &#34;6379&#34;
    data_type =&amp;gt; &#34;list&#34;
    key =&amp;gt; &#34;logstash&#34;
    type =&amp;gt; &#34;redis-input&#34;
  }
}

filter {
   grok {
      type =&amp;gt; &#34;linux-syslog&#34;
      pattern =&amp;gt; &#34;%{SYSLOGLINE}&#34;
   }

   grok {
       type =&amp;gt; &#34;nginx-access&#34;
       pattern =&amp;gt; &#34;%{IPORHOST:source_ip} - %{USERNAME:remote_user} \[%{HTTPDATE:timestamp}\] %{QS:request} %{INT:status} %{INT:body_bytes_sent} %{QS:http_referer} %{QS:http_user_agent} %{QS:x_forword} %{QS:upstream_cache_status}&amp;amp;@&amp;amp;(%{HOST:domain}|-)&#34;
   }
}

output {
  elasticsearch {
    host =&amp;gt; &#34;127.0.0.1&#34;
    port =&amp;gt; &#34;9301&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;java -jar logstash-1.3.3-flatjar.jar agent -f indexer.conf&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server2上运行Kibana，&lt;code&gt;java -jar logstash-1.3.3-flatjar.jar web&lt;/code&gt;，然后再浏览器中打开 &lt;code&gt;http://192.168.56.101:9292&lt;/code&gt;，应该可以看到统计结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上面的端口如果不能访问注意修改iptables，运行后如果页面还是不能访问，需要等几十秒。&lt;strong&gt;redis可以安装在server2上面，这样会不会更好？&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;关于filter的写法，这里我们最常使用的就是grok，可以参考logstash的官网，上面有很多介绍。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际上我们可以用logstash完成很多功能，比如报警功能(使用metrics插件和ruby插件)，统计nginx访问日志，并按照自己的需求，这个就需要对grok进行编码了，主要就是正则表达式的编写，如果一个grok不够的话，还可以加上一个grok，诸如此类的。&lt;/strong&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-03-02</pubDate>  
    </item>  
    <item>  
		<title>python相关知识点整理</title>  
		<link>http://daimin.github.io//posts/python-xiang-guan-zhi-shi-dian-zong-jie.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;operator.itemgetter函数，它的值指名从第几个元素操作
比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = [(&#39;a&#39;,1),(&#39;b&#39;,3),(&#39;c&#39;,2)]
a.sort(key=operator.itemgetter(1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：
[(&#39;a&#39;, 1), (&#39;c&#39;, 2), (&#39;b&#39;, 3)]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a.sort(key=operator.itemgetter(0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：
[(&#39;a&#39;, 1), (&#39;b&#39;, 3), (&#39;c&#39;, 2)]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;os.walk 和os.path.walk &lt;br /&gt;
    os.walk有3个参数，top,topdown和onerror，top是要遍历的根目录，topdown为True则从根目录到子目录，否则先遍历子目录，后根目录，onerror是发生错误时候回调的函数。
os.walk返回3个值，root、dirs、files，root是当前遍历的相对根目录，dirs是当前根目录下的所有目录列表,files是文件列表。&lt;/p&gt;
&lt;p&gt;os.path.walk没有返回，用来遍历目录并给每次遍历目录数回调函数，参数1是待遍历的目录，参数2是回调函数，参数3是回传给回调函数的参数。回调函数有3个参数，参数1便是os.path.walk函数的第3个参数传递的值，参数2是当前目录下的所有子目录列表，参数3是文件列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hashlib的update函数会在上次加密的基础上继续加密&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m.update(&#34;aaa&#34;)
&amp;gt;&amp;gt;&amp;gt; print m.hexdigest()
5d793fc5b00a2348c3fb9ab59e5ca98a
&amp;gt;&amp;gt;&amp;gt; print m.hexdigest()
5d793fc5b00a2348c3fb9ab59e5ca98a
&amp;gt;&amp;gt;&amp;gt; m.update(&#34;aaa&#34;)
&amp;gt;&amp;gt;&amp;gt; print m.hexdigest()
e09c80c42fda55f9d992e59ca6b3307d
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python使用绝对路径运行项目的时候，必须保证自己依赖的库和模块在绝对路径中能够找到，否则就切换到相对路径中执行。比如cron执行python时，可以先cd到当前项目路劲，然后执行当前的python脚本文件，cd xxxx;python xxxx.py&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python的类变量和java的不一样。对于JAVA来说，类变量只有一份，子类也是使用的父类的类变量，除非在子类中覆盖了父类的类变量，那么子类就会使用自己的类变量。而对于python来说，如果子类改变的类变量的值，那么不会影响到父类，其其它的子类。但是深究来说，我们重写给子类的类变量赋值，其实就相当于覆盖了该变量，因为python是动态变量，所以归根是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python中 // 一直执行取整除法，不过对于/，python2和python3会有不同，python3是浮点除法，不过在python2中可以通过引入 &lt;code&gt;from __future__ import division&lt;/code&gt; 使/为浮点除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表切片如果不存在，会返回空列表，而索引访问则会报错：IndexError: list index out of range&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = [1,3,24]
&amp;gt;&amp;gt;&amp;gt; s[10:]
&amp;gt;&amp;gt;&amp;gt; []
&amp;gt;&amp;gt;&amp;gt; s[10]
&amp;gt;&amp;gt;&amp;gt; IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xrange(N)，将返回0..N-1的生成器，range(N)讲返回0..N-1的列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lambda 表达式创建的函数其实是一个闭包函数，和普通函数是不一样的。如果调用一个lambda函数，可能会产生闭包函数已经完成调用，导致每次的值都是最后一次的值，可以在函数中定义额外的参数来保存每一次的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def multipliers():
    return [lambda x : i * x for i in range(4)]`  #  late binding 变量的值是在函数被调用的时候被查找的，那么这个时候循环早已完成，那么i的值就是循环最后的值了，也就是3.

def multipliers():
    return [lambda x, i=i : i * x for i in range(4)]  #这里使用了一个额外的参数i来绑定(消除lage binding)闭包中的i的值，那么在调用的适合，使用的i就是默认参数中的i的值了。

print [m(2) for m in multipliers()]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于函数的默认参数，只会在函数定义的时候创建，之后无论多少次的使用，都是使用的同一个。
如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def extendList(val, list=[]):
   list.append(val)
   return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList(&#39;a&#39;)

print &#34;list1 = %s&#34; % list1
print &#34;list2 = %s&#34; % list2
print &#34;list3 = %s&#34; % list3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的结果会是： &lt;br /&gt;
list1 = [10, &#39;a&#39;]&lt;br /&gt;
list2 = [123] &lt;br /&gt;
list3 = [10, &#39;a&#39;]&lt;br /&gt;
list1和list3使用的是同一个列表，只有list2，重新传入了一个list，所以是使用的传入的list。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type(x) 返回x的描述x的类型的type对象，，而isinstance(obj,class)，直接判断obj是否是class的实例，能作用于各种subclass，或者是新旧类型的类声明方式。而type(x)它不能对subclass起作用，对旧的类声明方式(class A:pass)也无作用，type(x)会返回&lt;type “instance”&gt;对象，与原类对象并不相等，新的类声明方式(class A(object):pass)是相等的，但是对于subclass也是不起作用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;builtin&lt;/strong&gt;模块代表了python中默认内置的函数的对象,如果碰到要重写buildin函数，可以import &lt;strong&gt;buildin&lt;/strong&gt;然后调用buildin函数，这样不会对对当前scope的函数造成影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;os模块是和操作系统相关的，sys适合解释器相关的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy 仅拷贝对象本身，而不拷贝对象中引用的其它对象。 deepcopy 除拷贝对象本身，而且拷贝对象中引用的其它对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;os.path是module，包含了各种处理长文件名(路径名)的函数。sys.path是由目录名构成的列表，python解释器依据这个查找模块及初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;re.match() 函数只检查 RE 是否在字符串开始处匹配，而 re.search() 则是扫描整个字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reduce是对集合中的item 进行归并，其实和map/reduce中的reduce的概念差不多。它有两个参数，分别代表前一次迭代的值及本次迭代item的值。它还拥有一个startval。
简单实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def reduce_impl(func, argvs, startVal=None):
   if startVal is not None:
       argv1 = startVal
   else:
       argv1 = argvs[0]

   for argv2 in argvs[1:]:
       argv1 = func(argv1, argv2)
   return argv1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成器和函数的主要区别在于函数 return a value，生成器 yield a value同时标记或记忆 point of the yield 以便于在下次调用时从标记点恢复执行。 yield 使函数转换成生成器，而生成器反过来又返回迭代器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__future__&lt;/code&gt;模块是未来python版本默认支持的特性，比如python3就支持了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from __future__ import unicode_literals # 默认字符串都是unicode的了
from __future__ import print_function # print语句现在是一个函数
from __future__ import division # &#39;/&#39;除法现在是浮点除
from __future__ import absolute_import # 要使用绝对导入，而不能使用相对导入的方式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__builtins__&lt;/code&gt;是对内建模块的引用，python2.*的&lt;code&gt;__builtin__&lt;/code&gt;或python3.x的&lt;code&gt;builtins&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(i for i in [1,2,3,4])&lt;/code&gt; 生成生成器，&lt;code&gt;[i for i in[1,2,3,4]]&lt;/code&gt; 生成列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__all__ = [&#34;add&#34;, &#34;x&#34;]&lt;/code&gt;，表示在import * 的时候，只会import 这些成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt;中的&lt;code&gt;__path__&lt;/code&gt;代表当前包的路劲，只要将当前包下的模块的解决路劲加入到path中，就可以从直接从包中引入了这些模块了。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个累中&lt;code&gt;__slots__ = (&#34;name&#34;, &#34;age&#34;)&lt;/code&gt;，那么就不能动态绑定其它的属性了，只能是&lt;code&gt;__slots__&lt;/code&gt;中的。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enumerate 会返回索引和元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;l = [1,2,32,4,22,5]

for idx, it in enumerate(l):
print &#34;{}=&amp;gt;{}&#34;.format(idx, it)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0=&amp;gt;1
1=&amp;gt;2
2=&amp;gt;32
3=&amp;gt;4
4=&amp;gt;22
5=&amp;gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inspect提供自省功能&lt;/p&gt;
&lt;p&gt;(1).对是否是模块，框架，函数等进行类型检查。&lt;/p&gt;
&lt;p&gt;(2).获取源码&lt;/p&gt;
&lt;p&gt;(3).获取类或函数的参数的信息&lt;/p&gt;
&lt;p&gt;(4).解析堆栈&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inspect.stack() # 得到当前代码的调用堆栈
is{module|class|function|method|builtin}(obj): #检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj): #用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is*()更方便，不过它的实现仍然是用了多个is*()。
getmembers(object[, predicate]):# dir函数的升级版本
getmodule # 它返回object的定义所在的模块对象。
# 此外还可以返回源码
get{file|sourcefile}(object): #获取object的定义所在的模块的文件名|源代码文件名
getargvalues(frame): # 仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组
#... 还有很多自省相关的函数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;requests的编码 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r = request.get(&#34;http://xxx.com&#34;)
print r.encoding
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;r.encoding 可以得到requests猜测的response的数据的编码，但是可能不正确，你可以自己检查response的编码，然后设置r.encoding=&#39;xxx&#39;，这样下一次调用r.text的时候就会使用r.encoding的编码将r.text的值转换为当前python解释器所用的字符编码的字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hashlib.md5编码错误&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hashlib.md5(u&#34;中文字符&#34;)&lt;/code&gt;是会报错的&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;br /&gt;
这个时候只要将需要hash的字符串先encode一下就行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;collections.defaultdict&lt;/p&gt;
&lt;p&gt;defaultdict(default_factory), 这样default的每个一value都是一个default_factory类型 &lt;br /&gt;
如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = [(&#39;yellow&#39;, 1), (&#39;blue&#39;, 2), (&#39;yellow&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1)]

# defaultdict
d = collections.defaultdict(list)
for k, v in s:
    d[k].append(v)
print d
# output: defaultdict(&amp;lt;type &#39;list&#39;&amp;gt;, {&#39;blue&#39;: [2, 4], &#39;red&#39;: [1], &#39;yellow&#39;: [1, 3]})

# 类似这样使用dict
g = {}
for k, v in s:
g.setdefault(k, []).append(v)
print g
# output: {&#39;blue&#39;: [2, 4], &#39;red&#39;: [1], &#39;yellow&#39;: [1, 3]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;defaultdict会比dict的setdefault的速度要快&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-02-14</pubDate>  
    </item>  
    <item>  
		<title>写了一个静态博客</title>  
		<link>http://daimin.github.io//posts/write-a-static-blog.html</link>  
		<description>&lt;p&gt;BAE的域名要备案了，所以我的原来的博客&lt;a href=&#34;http://codecos.com&#34;&gt;http://codecos.com&lt;/a&gt;，无法使用了。找了一下国内的其它的免费的空间或引擎都是需要域名备案的。&lt;/p&gt;
&lt;p&gt;之前就知道github是可以创建个人网站，还可以绑定一个域名，这货可是国外的，就不需要域名备案。&lt;/p&gt;
&lt;p&gt;gihub pages使用的是Jekyll引擎，如果你以一定的结构存放markdown文档的话，是可以自动生成html的，我这里没有去用这个，学习一个东西好像没什么必要，你可以参考&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我使用python开发的，网站根据一定的结构组织，使用mako模板引擎，markdown文档放在一个指定的目录，然后执行以下python脚本就可以解析markdown文档并使用模板生成整个网站的内容了。&lt;/p&gt;
&lt;p&gt;对比我之前的网站，这个网站是全静态化的，速度上会有优势，而且文章和tag的URL更加的友好，总之我比较满意。&lt;/p&gt;
&lt;p&gt;网站地址：&lt;a href=&#34;http://blog.codecos.com&#34;&gt;http://blog.codecos.com&lt;/a&gt;，就是这篇文章所在。&lt;/p&gt;
&lt;p&gt;代码：&lt;a href=&#34;https://github.com/daimin/daimin.github.com&#34;&gt;https://github.com/daimin/daimin.github.com&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下一步我该做一个怎样的应用呢？&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-02-13</pubDate>  
    </item>  
    <item>  
		<title>使用RSA在Java端私钥加密，PHP端公钥验证</title>  
		<link>http://daimin.github.io//posts/shi-yong-RSA-zai-Java-duan-si-yao-jia-mi-PHP-duan-gong-yao-yan-zheng.html</link>  
		<description>&lt;p&gt;工作需要研究下RSA加密解密算法，一不小心差点把自己搞疯了，主要是我们服务器是PHP，而客户端肯定以后是Java了。所以我需要的是在Java端用私钥加密，而服务器用公钥进行验证。在这两端进行RSA加密解密需要严格的要求，这里我主要做一下记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先是Java端：&lt;/strong&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用的是javax.crypto.Cipher库，一般来说最好使用这个库，因为Android里面也带有这个库，而且使用起来比较方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成私钥公钥对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&#34;RSA&#34;);

//密钥位数

keyPairGen.initialize(1024);

//密钥对

KeyPair keyPair = keyPairGen.generateKeyPair();

// 公钥

PublicKey publicKey = (RSAPublicKey) keyPair.getPublic();

// 私钥

PrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取私钥，使用PKCS8EncodedKeySpec来生成，Base64库最好使用org.apache.commons.codec4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;byte[] keyBytes;

keyBytes = Base64.decodeBase64(key);

PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);

KeyFactory keyFactory = KeyFactory.getInstance(&#34;RSA&#34;);

PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里需要注意的是获取instance的时候必须是&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;，否则php是不支持pkcs8的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cipher cipher = Cipher.getInstance(&#34;RSA/ECB/PKCS1Padding&#34;);

cipher.init(Cipher.DECRYPT_MODE, ppkey);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;好像加密的时候，好像不能一次性对超过117个字节的数据加密，可以做如下的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;byte[] enBytes = null;

int i = 0;

for (i = 0; i &amp;lt; ptext.length; i += 64) {

      // 注意要使用2的倍数，否则会出现加密后的内容再解密时为乱码

      byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(ptext, i,i + 64));

      enBytes = ArrayUtils.addAll(enBytes, doFinal);

}

return enBytes;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意的是这里加密的话，最好对原文进行MD5之后，在加密，那么在PHP端，进行验证的时候，只要验证原文的MD5值就行了，因为PHP的openssl对于比较长的字符串，好像并不能进行处理，Java没有此问题。&lt;strong&gt;就是这里困了我好久&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;服务器PHP端&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保存公钥，放到文件中，还是数据库中随便，不过需要注意的是Java中的公钥、私钥只有字符串就OK，但是PHP中的是有指定格式的，必须这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----

MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCFtYP+8zOR2WPJe/0c0w3kf3vmzcDksDPFgaqI

psR+587tPm5YgZc53ii90wXsmjwVedU8yM8aZYpg7ZZALAximTR/JnK3A/+ffQG7lmNM0zC9StsD

S3rD9bNIj0jGHUBT5Dxf98+TnEojWECeg5ZibZ51xzN8tChqB7MmApBIGwIDAQAB

-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过下面的函数处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function setupPubKey($pubkey) {

    if (is_resource ( $pubKey )) {

        return true;

    }

    $pem = chunk_split($pubkey,64,&#34;\n&#34;);

    $pem = &#34;-----BEGIN PUBLIC KEY-----\n&#34;.$pem.&#34;-----END PUBLIC KEY-----\n&#34;;

    $pubkey = openssl_pkey_get_public ( $pem );

    return $pubkey;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意的是，这里验证的是原文的md5值，这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$result = (bool)openssl_verfify(md5($plainText),base64_decode($sign), OPENSSL_ALGO_DSS1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须使用OPENSSL_ALGO_DSS1，我也不知道为什么，估计是和&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;对应，&lt;/p&gt;
&lt;p&gt;不过在使用alipay或者     wandoujia进行签名验证的时候，可能不需要这个参数，请酌情增、删。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这个东西话费了我很多时间才调通，差点放弃，语言间对于RSA的实现会有所不同，描述也会有所不同。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-11-23</pubDate>  
    </item>  
    <item>  
		<title>走着走着，花就开了</title>  
		<link>http://daimin.github.io//posts/zou-zhao-zou-zhao-hua-jiu-kai-le.html</link>  
		<description>&lt;p&gt;优柔寡断，是人生最大的负能量。&lt;/p&gt;
&lt;p&gt;人生没什么好优柔的。&lt;/p&gt;
&lt;p&gt;从生命角度去看，你人生路径上的任何一种选择都是错误的，无论你怎么选，都有差错；&lt;/p&gt;
&lt;p&gt;因此，当选择来临，A和B，拿一个便走就是。&lt;/p&gt;
&lt;p&gt;人生没有对错，只有选择后的坚持，不后悔，走下去，就是对的。&lt;/p&gt;
&lt;p&gt;我最喜欢的一句诗就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;走着走着，花就开了。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-11-08</pubDate>  
    </item>  
    <item>  
		<title>自省和计划</title>  
		<link>http://daimin.github.io//posts/zi-sheng-he-ji-hua.html</link>  
		<description>&lt;h6&gt;技术上会的东西&lt;/h6&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;java: java基本语法熟练，熟悉android、javaweb开发，SSH框架之类的都忘记了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;php: php语法熟练，能使用纯php构建web系统，codeigniter和thinkphp框架熟悉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python: python语法熟悉，web.py熟悉，django学习中，了解pyqt开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS相关: javascript掌握,jquery熟悉，能开发nodejs程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库：比较熟悉的就只有mysql了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linux常用命令的使用，系统环境搭建，简单的系统维护都能做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其它：html、css都熟悉，除了不会做美术设计，其它的基本都OK了。c/c++也算了解，能做简单的开发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h5&gt;接下来的该学的&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;python的django框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解计算机网络知识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统知识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据结构和算法的知识&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;除了django外，其它都是一些计算机基本知识了，学过这么多样的东西，其实真没必要再去学其它的具体开发技术了，如果还想做几年程序，计算机的基本知识和理论才是重要的，当然我也没那么偏激去学高等数学什么的。加油吧!&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-10-10</pubDate>  
    </item>  
    <item>  
		<title>一个非常非常简单的markdown编辑器</title>  
		<link>http://daimin.github.io//posts/yi-ge-fei-chang-fei-chang-jian-dan-de-markdown-bian-ji-qi.html</link>  
		<description>&lt;p&gt;之前一直使用&lt;em&gt;markdownPad&lt;/em&gt;，功能是很强大，但是那个速度我就不想吐槽了，其实我只需要一个非常简单的markdown编辑器，只要简单的预览就够了，所以就有了这个markdown的编辑器。你可以在&lt;a href=&#34;https://github.com/daimin/mdchick&#34;&gt;这里&lt;/a&gt;得到它的源码。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;简单的介绍：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为我的&lt;a href=&#34;http://codecos.com&#34;&gt;博客&lt;/a&gt;是用python写的，所以其markdown也是用的python的库进行解析的，然后大多数的md的编辑器都和博客使用的库的解析结果有所不同，包括markdownPad，只是它稍微好些而已，所以我就想自己用python来做一款简单的markdown的编辑器，这样写起博客来，就非常顺畅了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑器使用&lt;a href=&#34;http://www.riverbankcomputing.co.uk/software/pyqt/download/&#34;&gt;pyqt4&lt;/a&gt;来编写，为什么不用qt?因为我不会，而且我要的是python的程序，这样才能最好的和博客一致。pyqt应该是python中最强大的UI库之一吧，很好用，文档多，而且很多的示例，强烈推荐之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在编辑器的功能只有编辑和预览的功能，后续应该会有&lt;strong&gt;加粗&lt;/strong&gt;，&lt;strong&gt;斜体&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;插入代码块&lt;/strong&gt;，再加上nodepad的功能，不会更多了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;已经加上了&lt;strong&gt;加粗&lt;/strong&gt;，&lt;strong&gt;斜体&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;插入代码块&lt;/strong&gt;，等一些简单的功能。如果感兴趣，请参考&lt;a href=&#34;https://github.com/daimin/mdchick&#34;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天晚上要回家了，开心，激动，嘎嘎！&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-25</pubDate>  
    </item>  
    <item>  
		<title>用python进行博客的迁移</title>  
		<link>http://daimin.github.io//posts/yong-python-jin-xing-bo-ke-de-qian-yi.html</link>  
		<description>&lt;p&gt;今天将原来的博客的博文全部移植到了 &lt;a href=&#34;codecos.com&#34;&gt;codecos&lt;/a&gt; 上面，其实blogjava.net里面有功能的，它是导出为xml，可是我看导出后的xml，解析起来，还要比直接解析html麻烦些，所以还是用python写了一个抓取的脚本。&lt;/p&gt;
&lt;p&gt;脚本的功能用到了多线程、urllib2进行GET请求，urllib2、urllib1、cookielib进行POST请求，BeautifulSoup对html数据进行分析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从我原来的博客 &lt;a href=&#34;http://www.blogjava.net/vagasnail&#34;&gt;http://www.blogjava.net/vagasnail&lt;/a&gt;中抓取数据，用的urllib2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;req = urllib2.Request(self.url)

response = urllib2.urlopen(req)

the_page = response.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于开始使用单线程，很慢啊，基本上不能运行成功，不得已使用了多行程的方式，每一个url的抓取、解析数据和向目标博客POST数据都会启动一个新的线程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 建立线程类从threading.Thread继承

class FetchThread(threading.Thread):

    def run(self):

        # 这个函数是必须实现的，其实和JAVA中的Thread类是如此的像

        # 线程实际运行就是这个函数

        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用的解析库是BeautifulSoup，这个非常好用啊。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;soup = BeautifulSoup(data)

#拿到所有的链接

alinks =  soup.find_all(&#39;a&#39;)

#正则表达式，因为不是所有的链接都有用的

pattern1 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/articles/[0-9]+\.html$&#39;)

pattern2 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/archive/[0-9]{4}/[0-9]{2}/[0-9]{2}/[0-9]+\.html$&#39;)

pattern3 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/category/[0-9]+\.html$&#39;)

pattern4 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/archive/[0-9]{4}/[0-9]{2}\.html$&#39;)

#拿到标题，标题是ID标识的

title = soup.find_all(id=&#34;viewpost1_TitleUrl&#34;)

#只要文本数据就行了

art[&#39;title&#39;] = title[0].get_text()

#拿到内容

content = soup.find_all(&#39;div&#39;, class_=&#34;postbody&#34;)

#内容应该所有HTML字符

art[&#39;content&#39;] = str(content[0])

#发布日期是直接作为普通的文本节点在里面的，没办法只能用正则了

re.M表示多行模式

pattern_date = re.compile(r&#39;([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2})&#39;,re.M)

#必须要用findall它会查询字符串中匹配模式的所有子字符串

pdates = pattern_date.findall(str_postfoot)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就是POST到&lt;a href=&#34;codecos.com&#34;&gt;目标博客&lt;/a&gt;了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#引入要用的库

import urllib,urllib2,cookielib

cj = cookielib.CookieJar()

#处理POST数据的URL

b_url =&#39;http://codecos.com/****&#39;

art[&#39;tag&#39;] = &#34;,&#34;.join(art[&#39;tag&#39;])

#art是列表这里把它转成元组

body = art.items()

#设置cookie

opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))

#模拟浏览器请求

opener.addheaders = [(&#39;User-agent&#39;,

    &#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#39;)]

urllib2.install_opener(opener)

#发送请求

req = urllib2.Request(b_url, urllib.urlencode(body))

u = urllib2.urlopen(req)

u.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所以&lt;a href=&#34;codecos.com&#34;&gt;我的博客&lt;/a&gt;现在的已经有很多文章了，不过有些还是样式有些问题，只能手动调整了。&lt;/p&gt;
&lt;p&gt;还有这些不是用&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;markdown&lt;/a&gt;写的，改起来很麻烦啊，所有还是&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;markdown&lt;/a&gt;舒服啊。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-14</pubDate>  
    </item>  
    <item>  
		<title>PHP+Mysql+Sphinx(coreseek)站内搜索引擎的搭建</title>  
		<link>http://daimin.github.io//posts/PHP-Mysql-Sphinx-coreseek-zhan-nei-sou-suo-yin-qing-de-da-jian.html</link>  
		<description>&lt;p&gt;后台搜索速度越来越慢，考虑着用专业的搜索工具。   &lt;/p&gt;
&lt;p&gt;Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。 它提供php,java,ruby,python等多种语言的api。&lt;/p&gt;
&lt;p&gt;我这里使用的是coreseek，Coreseek为应用提供全文检索功能，目前的版本（2.x 3.x）基于Sphinx 0.9.8，支持使用Python定义数据源，支持中文分词。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装coreseek，在这里&lt;a href=&#34;http://www.coreseek.cn/uploads/csft/4.0/coreseek-4.1-win32.zip&#34;&gt;下载&lt;/a&gt;coreseek最新版4.1。下载后直接解压就行了。比如说 D:\coreseek-4.1-win32。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改etc目录下面的 csft_mysql.conf文件。首先是数据源定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#数据源定义

source mysql

    {

        type                    = mysql

        sql_host                = localhost

        sql_user                = root

        sql_pass                =

        sql_db                  =

        sql_port                = 3306

        sql_query_pre           = SET NAMES utf8

        sql_query = SELECT id, group_id, type, UNIX_TIMESTAMP(date_added) AS date_added, title, content FROM documents

        sql_attr_uint    = group_id

        sql_attr_timestamp  =  date_added

        sql_query_info_pre      = SET NAMES utf8

        sql_query_info          = SELECT * FROM payinfo WHERE id=$id

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;type: 数据库类型，目前支持 mysql 与 pgsql &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_host、sql_user、sql_pass、sql_port: mysql数据库的相关配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_query_pre： 索引数据获取前执行的查询，这里用来设置字符集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_query: 全文检索要显示的内容，在这里尽可能不使用where或 group by，将 where 与 groupby 的内容交给 sphinx，由 sphinx 进行条件过滤与 groupby 效率会更高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_attr_*: 表示一些属性字段，你原计划要用在 where, orderby, groupby 中的字段要在这里定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_query_info： 文档信息查询。 可选选项，默认为空。 仅对 mysql 数据源有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sql_query_info_pre： 命令行查询前查询。 可选选项，默认为空。 仅对 mysql 数据源有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#index定义

index mysql

{

    source            = mysql

    path            = var/data/mysql

    docinfo            = extern

    mlock            = 0

    morphology        = none

    min_word_len        = 1

    html_strip                = 0

    charset_dictpath = etc/                             #Windows环境下设置，/符号结尾，最好给出绝对路径，例如：C:/usr/local/coreseek/etc/...

    charset_type        = zh_cn.utf-8

    enable_star = 1

    min_infix_len = 3

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source 源名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;path 索引记录存放目录，如 d:/sphinx/data/cgfinal ,实际存放时会存放在 d:/sphinx/data 目录，然后创建多个 cgfinal 名称，不同扩展名的索引文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docinfo: 文档信息(docinfo)的存储模式。可选选项，默认是“extern”，可用的值包括&#39;none&#39;, &#39;extern&#39; 和 &#39;inline&#39;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;min_word_len: 最小索引词长度。可选选项，默认为1（索引任何词）。只有长度不小于这个最小索引词长度的词会被索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;charset_type: 字符集编码类型。可选选项，默认为“sbcs”。可用的值包括“sbcs”和“utf-8”。 对于使用Coreseek的中文用户，可选的值还可以有“zh_cn.utf-8 ”、“zh_cn.gbk”和“zh_cn.big5”（需要编译时提供iconv支持）。当设置charset_type值为上面的值时，系统默认您开启了中文分词特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;charset_dictpath: 设置中文分词词典所在的目录，默认是mmseg3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enable_star: 允许前缀/中缀索引上的星号语法（或称通配符）。可选选项，默认为0（不使用通配符）。可用值为1或者0。所有关键字都根据索引时的 min_prefix_len 和 min_infix_len settings设置被视为前缀或者中缀。如&lt;em&gt;da&lt;/em&gt;, *dai&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;min_infix_len：索引的最小中缀长度。可选选项，默认为0（不索引中缀）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;min_prefix_len：索引的最小前缀长度。可选选项，默认为0（不索引前缀）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前缀和中缀不能同时索引。索引了前缀和中缀会使索引慢很多，请斟酌。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其它的参数请参见 &lt;a href=&#34;http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#conf-min-infix-len&#34;&gt;Coreseek 4.1 参考手册&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局索引定义 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#全局index定义

indexer

{

    mem_limit            = 128M

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;mem_limit 索引使用内存最大限制，根据机器情况而定，默认是32M，太小的会影响索引的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;searchd服务定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;searchd

{

    listen                  =   9312

    read_timeout        = 5

    max_children        = 30

    max_matches            = 1000

    seamless_rotate        = 0

    preopen_indexes        = 0

    unlink_old            = 1

    pid_file = var/log/searchd_mysql.pid  #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...

    log = var/log/searchd_mysql.log        #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...

    query_log = var/log/query_mysql.log #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...

    binlog_path =                                #关闭binlog日志

}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这个不多，请参见手册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成索引并启动后台&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\coreseek-4.1-win32&amp;gt;bin\indexer -c etc\csft_mysql.conf --all

# 索引配置中定义的所有索引。

D:\coreseek-4.1-win32&amp;gt;bin\searchd -c etc\csft_mysql.conf --console

# 运行检索守护进程

# 另外打开一个CMD窗口，然后：

D:\coreseek-4.1-win32&amp;gt;bin\search -c etc\csft_mysql.conf -a 100

# 查询所有包含100的文档。注意这里的需要考虑的分词规则，100成功，可能10就不会成功。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;php客户端使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require ( &#34;sphinxapi.php&#34; );

# sphinx提供的PHP客户端。

$cl = new SphinxClient ();

$cl-&amp;gt;SetServer(&#39;127.0.0.1&#39;, 9312);

$cl-&amp;gt;SetConnectTimeout ( 3 );

$cl-&amp;gt;SetArrayResult ( true );

$cl-&amp;gt;SetMatchMode ( SPH_MATCH_EXTENDED);

$res = $cl-&amp;gt;Query ( &#39;all&#39;, &#34;*&#34; );

print_r($res[&#39;matches&#39;]);

# 连接到searchd服务器，根据服务器的当前设置执行给定的查询(搜索所有的索引中包含all)，取得并返回结果集。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;只是一个简单的记录，主要是自己备忘。详细的使用方式，参见 &lt;a href=&#34;http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#conf-min-infix-len&#34;&gt;Coreseek 4.1 参考手册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-10</pubDate>  
    </item>  
    <item>  
		<title>Nginx+uWsgi+web.py 搭建与简单测试</title>  
		<link>http://daimin.github.io//posts/Nginx-uWsgi-web-py-da-jian-yu-jian-dan-ce-shi.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;Nginx + uWsgi + web.py 效率真是不错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装uWsgi  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先是下载 &lt;a href=&#34;http://projects.unbit.it/downloads/uwsgi-1.9.14.tar.gz&#34;&gt;http://projects.unbit.it/downloads/uwsgi-1.9.14.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压 &lt;code&gt;sudo python setup.py build&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;make&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx和web.py的安装就不多说&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {

  include uwsgi_params;

  #uwsgi_pass 127.0.0.1:9002;

  #对应uwsgi.ini配置的socket文件

  uwsgi_pass unix:/tmp/uwsgi.sock;

}

#静态文件访问

location /static/ {

  if (-f $request_filename) {

    rewrite ^/static/(.*)$  /static/$1 break;

  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于web.py的脚本index.py&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import web

urls = (&#34;/.*&#34;, &#34;hello&#34;)

app = web.application(urls, globals())

class hello:

    def GET(self):

        return &#39;Hello, world!&#39;

#if __name__ == &#34;__main__&#34;: #注意将改行注释掉

application = app.wsgifunc()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uWsgi的配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[uwsgi]

#socket = 127.0.0.1:9002

#用socket文件方式

socket = /tmp/uwsgi.sock

chdir = /data/www/webpy/

processes = 8

threads = 2

master = true

module = index

;pidfile = /data/uwsgi-bin/uwsgi.pid

;listen = 128

#守护进程方式运行，并指明日志文件

daemonize = /data/www/webpy/uwsgi.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意chdir指向程序目录，module是主运行文件，见上，加入pidfile后好像对性能有影响，所以这里注释掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;sudo uwsgi uwsgi.ini&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试使用的是apache的ab工具。&lt;code&gt;ab -n1000 -c100 http://192.168.1.1:8080/&lt;/code&gt;，结果如下： &lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377586380417.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377586380417.gif&#34; title=&#34;web.py&#34; /&gt;&lt;/p&gt;
&lt;p&gt;拿php来测试下，同样的服务器,同样的nginx，使用的是nginx + php-fpm fastcgi的模式。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377586409480.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377586409480.gif&#34; title=&#34;php&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看得出比PHP还是快了不少&lt;/strong&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-27</pubDate>  
    </item>  
    <item>  
		<title>BAE中文编码引起的程序崩溃</title>  
		<link>http://daimin.github.io//posts/BAE-zhong-wen-bian-ma-yin-qi-de-cheng-xu-beng-kui.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;qiniu_1377505253074.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377505253074.jpg&#34; title=&#34;python&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我的博客修改了一些东西，主要是中文编码问题，在自己的机器上面是没有问题的。只是在BAE上面会有问题，而且这个问题又不是每次都出现，所以很纠结，查看了很久的日志&lt;em&gt;因为日志查询真的很慢啊，有木有啊&lt;/em&gt;，在&lt;code&gt;index.py&lt;/code&gt;中加上了如下的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys

reload(sys)

sys.setdefaultencoding(&#39;utf-8&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统的默认编码。&lt;/p&gt;
&lt;p&gt;可以去github上面下载相关的代码：&lt;a href=&#34;https://github.com/daimin/tolog&#34;&gt;https://github.com/daimin/tolog&lt;/a&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-26</pubDate>  
    </item>  
    <item>  
		<title>mysql 用法备忘</title>  
		<link>http://daimin.github.io//posts/mysql-yong-fa-bei-wang.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;工作中一直都用mysql，遇到一些问题，需要查来查去，下一次遇到相同的又忘记，又要查，很不方便啊，这次记在这里，备查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377507698298.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377507698298.jpg&#34; title=&#34;mysql&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Alter语句用法   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改列的类型信息   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT &#39;注释说明&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 重命名列
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT &#39;注释说明&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 重命名表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ALTER TABLE 【表名字】 RENAME 【表新名字】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显示运行线程和杀死线程   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show processlist;

kill connection threadid;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;replace into&lt;/code&gt; 会修改具有相同键的数据行的所有列的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导出查询结果到文件   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT id,dbname FROM `index` into outfile &#34;d://aaa.txt&#34;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改表的默认字符集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;&lt;/code&gt; 转换表及所有字符字段的字符集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql添加用户   &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好吧BAE不让我录入下面的sql语句，我读进行过滤了的啊，坑啊，难怪那么慢，过滤了多少东西啊，无力吐槽，图片看你怎么过滤！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377508847990.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377508847990.gif&#34; title=&#34;mysql&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;绑定mysql服务到指定IP&lt;/p&gt;
&lt;p&gt;命令行启动时，使用   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/local/mysql/bin/mysqld_safe --bind-address=127.0.0.1&lt;/code&gt; 即可。  &lt;/p&gt;
&lt;p&gt;如果需要修改服务脚本，编辑/etc/init.d/mysqld，找到第330行，将此内容：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;$bindir/mysqld_safe --datadir=$datadir --pid-file=$server_pid_file $other_args&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;修改为：   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$bindir/mysqld_safe --datadir=$datadir --pid-file=$server_pid_file --bind-address=127.0.0.1 $other_args&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即可。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;启动服务后，使用netstat -nat|grep 3306可以看到服务只绑定在127.0.0.1上。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;distinct 和 group by    &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种语句其实都差不都，distinct使用起来会方便些，group by 在加了索引后效率会高一些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DATE_FORMAT 函数用法   &lt;/p&gt;
&lt;p&gt;DATE_FORMAT(paytime, &#39;%Y-%m-%d&#39;)，这里paytime是待格式化的日期，%Y就是年，%m月，%d日，很简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert和select&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;replace into temp(`username`,`date`) select username,DATE_FORMAT(paytime, &#39;%Y-%m-%d&#39;) as paydate from pay_detail where `paytime`&amp;lt;=&#39;2013-08-25 23：59：59&#39; and `paytime`&amp;gt;=&#39;2013-07-26 00：00：00&#39; group by username
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;以后遇到新的问题，还会增加在这里。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-26</pubDate>  
    </item>  
    <item>  
		<title>在BAE上面搭建基于web.py的博客（一）</title>  
		<link>http://daimin.github.io//posts/zai-BAE-shang-mian-da-jian-ji-yu-web-py-de-bo-ke-yi.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载安装python，我这里安装的是python2.6.5。你可以从&lt;a href=&#34;http://www.python.org/getit/&#34;&gt;这里&lt;/a&gt;下载安装，我使用的系统是windowsxp。你只要下载相应的版本了。然后点击安装就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载web.py，从&lt;a href=&#34;http://webpy.org/install&#34;&gt;这里&lt;/a&gt;下载，对于web.py我没有安装，直接放置到工程木下面而已。你可以解压压缩包，然后运行&lt;code&gt;python setup.py install&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我使用的开发工具的pydev，这是一个eclipse的python开发插件，如果你感觉卡，可以调整eclipse.ini的-Xms，默认好像是40m，可以到-Xms256m。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板引擎，web.py自带有一个模板引擎，但是功能较弱，而且运行速度也不怎么样，我最开始也是使用的这个引擎，但是用起来有很多局限性，我这里推荐&lt;a href=&#34;http://www.makotemplates.org/&#34;&gt;mako&lt;/a&gt;，这个引擎的速度号称是python里面最快的模板引擎了，具体我也没有验证过，不过确实好用，确定就是文档比较少，不过你还是可以在网上找到一些资料，如：&lt;a href=&#34;http://www.cnblogs.com/RChen/archive/2007/06/15/mako_doc_translation_2.html&#34;&gt;http://www.cnblogs.com/RChen/archive/2007/06/15/mako_doc_translation_2.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于前端页面，你可以自己写一套，你也可以去拿一套现存的，你不知道哪里有？wordpress那么多好看的主题，难道不是吗？找到你心仪的主题，然后很快的用web.py改成你自己的网站，岂不是很爽。不过不要忘记加上主题的作者信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用markdown进行写作，比如我现在写的这篇文件就是用markdown写的，&lt;a href=&#34;https://pypi.python.org/pypi/Markdown&#34;&gt;python的markdown处理包&lt;/a&gt;，下载对应你的python版本的包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BAE百度的人品之作，速度不错，免费配额也不错，Python支持也不错，比起国外的还要靠谱很多。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最简单的helloworld。你可以在&lt;a href=&#34;http://webpy.org/cookbook/helloworld.zh-cn&#34;&gt;web.py cookbook&lt;/a&gt;上面找到。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import web

urls = (&#34;/.*&#34;, &#34;hello&#34;)

app = web.application(urls, globals())

class hello:

    def GET(self):

        return &#39;Hello, world!&#39;

if __name__ == &#34;__main__&#34;:

    app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭建我们的博客&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用pydev建立一个工程就OK了，假定该工程为&lt;strong&gt;demo&lt;/strong&gt;，然后将&lt;strong&gt;web.py的包文件夹&lt;/strong&gt;，&lt;strong&gt;mako的包文件夹&lt;/strong&gt;,&lt;strong&gt;markdown包文件夹&lt;/strong&gt;，拷贝到该工程下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在工程根目录建立文件夹templates,建立静态文件夹static，默认static目录中的文件，可以通过URL直接访问，当然这是在你本地，如果是在BAE上面就需要写处理脚本了，当然你也可以放在其它的服务器上面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义urls&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;urls = (

   r&#39;/(\d*)&#39;, &#39;Index&#39;,

)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;url采用的一个url的正则匹配一个逻辑处理类，我这里称之为handler。&lt;/p&gt;
&lt;p&gt;(\d*)对应了Index的GET或POST方法的出self参数外的第一个参数。&lt;/p&gt;
&lt;p&gt;注意url配置，要用r前缀，表示不对正则中的\进行转义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 3个root变量



        app_root = os.path.dirname(__file__)

        templates_root = os.path.join(app_root, &#39;templates/&#39; + conf.theme)

        static_root = os.path.join(app_root, &#39;static&#39;)



* 定义mako的模板渲染器



        render = render_mako(

            templates_root,

            input_encoding=&#39;utf-8&#39;,

            output_encoding=&#39;utf-8&#39;,

        )



* 定义一个基类，因为业务中，我们有很多都是相同的，那么我们就放在基类中进行处理。



        class Base():

            def __init__(self):

                self._conf = conf.site

                #do what you want.



* 定义Index类。



        class Index(Base):

            def __init__(self):

                Base.__init__(self)#必须调用基类的构造函数



            def GET(self, page):

                self.say = &#34;Hello World&#34;

                return render.index(page=self)





    在子类的构造函数中必须要调用基类的构造函数，web.py中用GET方法处理客户端的get请求，对应的POST方法处理post请求，GET和POST方法中的处理第一个参数外的参数，都是对应url中的捕获组中的值。



    `render.index`中的index表示一个模板文件，其中的参数是可以在模板中直接访问的，如果是web.py的模板，就需要$def with (page)后才可以使用，mako中可以直接使用的。



* 运行



    本机就这样运行，然后在浏览器中输入localhost:8080，就可以访问了，8080可以修改为你绑定的端口。



        web.config.debug = True

        app = web.application(urls, globals())

        app.notfound = errNotFound

        if __name__ == &#34;__main__&#34;:

            app.run()



    如果是在BAE上面就是这样，



        app = web.application(urls, globals()).wsgifunc()



        from bae.core.wsgi import WSGIApplication

        application = WSGIApplication(app)



    然后还要在BAE上面注意的是**修改app.conf的handler**加上：



        - url : /(\d*)

        script : index.py



    **之后还要着重的介绍一下BAE的使用。**
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;有什么不对的地方还请留言指正，大家一起学习。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-23</pubDate>  
    </item>  
    <item>  
		<title>用Python发垃圾邮件</title>  
		<link>http://daimin.github.io//posts/yong-Python-fa-la-ji-you-jian.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;qiniu_1376907717364.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376907717364.jpg&#34; title=&#34;解析页面发邮件&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个程序写了很久了，是刚开始学习python的时候写的，主要就是抓取页面的邮箱，然后发送。直接看代码吧，是我少有的注释比较详细的代码了，希望会有点参考价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

# -*- coding:UTF-8 -*-

#encoding=utf-8

#author:daimin(vagasnail#gmail.com)

&#34;&#34;&#34;

  1 能发送到多个邮箱

  2 使用多线程

  3 抓取指定的网页得到网页中的邮箱，然后发送(通过命令行参数获取网页地址)

&#34;&#34;&#34;

import sys

import smtplib

from email.Message import Message

from time import sleep

import threading

import urllib2,urllib

from BeautifulSoup import BeautifulSoup

from BeautifulSoup import BeautifulStoneSoup

import re





to_addrs = [&#39;target@xx.com&#39;]       #目标邮箱

cc_addr = &#39;cc@xx.com&#39;              #抄送

from_addr = &#39;from@xxx.com&#39;         #发送邮箱



# 标题和正文

    subject = u&#39;这不是垃圾邮件&#39; # u表示该字符使用unicode方式编码，注意这里只是起指示作用，用于一些函数处理

    content = u&#39;你好，测试用的&#39;



    class MyThread(threading.Thread):

    # const

    smtpserver = &#39;smtp.gmail.com&#39;

    username = &#39;vagasnail@gmail.com&#39;

    password = &#39;dai253685&#39;





    def __init__(self,no,msg,to_addr):

        threading.Thread.__init__(self) # 调用parent的__init__方法

        self.no = no

        self.msg = msg

        self.to_addr = to_addr



    def run(self):

        self.send_message()



    def send_message(self):

        print &#34; start thread %d ....\n&#34; % (self.no)

        sm = smtplib.SMTP(MyThread.smtpserver, port=587, timeout=20)

        sm.set_debuglevel(1)                   #开启debug模式

        sm.ehlo()

        sm.starttls()                          #使用安全连接

        sm.ehlo()

        sm.login(MyThread.username, MyThread.password)



        sm.sendmail(from_addr, self.to_addr, self.msg)

        sleep(5)

        sm.quit()



# 使用urllib2 获取html文档

# 使用BeautifulSoup解析html文档

def get_to_addrs(url):

    #pattern = re.compile(r&#39;^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$&#39;)

    pattern = re.compile(r&#39;\w+[\.\w]+@\w+\.\w+&#39;)

    global to_addrs

    req = urllib2.Request(url)

    res = urllib2.urlopen(req, timeout=10)

    html = res.read()

    res.close()



    match = pattern.findall(html)

    to_addrs.extend(match)

    #soup = BeautifulStoneSoup(html)

    &#39;&#39;&#39;

    ass = soup.findAll(&#34;a&#34;)

    for a in ass:

        h = a.get(&#39;href&#39;)

        if h &amp;lt;&amp;gt; None:

            h = h.strip()

            pos = h.find(tag)

            if pos &amp;lt;&amp;gt; -1:

                mail = h.replace(tag,&#39;&#39;)

                mail = mail.strip()

                to_addrs.append(mail)

    &#39;&#39;&#39;



if __name__ == &#34;__main__&#34;:

    &#34;&#34;&#34;

因为解码是python自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。

很多情况下 sys.defaultencoding 是 ANSCII，如果 s 不是这个类型就会出错。

拿上面的情况来说，我的 sys.defaultencoding 是 anscii，而 s 的编码方式和文件的编码方式一致，是 utf8 的。

你可以明确的s.decode(xxx).encode(xxxx)来编码解码 (解码：将编码解释为字符串，编码：将字符串编码)

    &#34;&#34;&#34;

    reload(sys)  # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入

    sys.setdefaultencoding( &#34;utf-8&#34; )



    if len(sys.argv) &amp;lt;&amp;gt; 2:

        print &#34;    Please input target page&#39;s url which you want handle!&#34;

        exit(0)



    url = sys.argv[1]

    get_to_addrs(url)

    print to_addrs



    tno = 1

    for to_addr in to_addrs:

        message = Message()

        #message.set_charset(&#39;&#39;)





        message[&#39;Subject&#39;] = subject    #邮件标题

        message[&#39;From&#39;] = from_addr

        message[&#39;To&#39;] = to_addr

        message[&#39;Cc&#39;] = cc_addr

        message.set_payload(content)    #邮件正文

        msg = message.as_string()

        #send_message(tno,msg,to_addr)

        t = MyThread(tno,msg,to_addr)

        t.start()

        tno = tno + 1
&lt;/code&gt;&lt;/pre&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-19</pubDate>  
    </item>  
    <item>  
		<title>数值调整后职业DPS模拟 DK逆袭</title>  
		<link>http://daimin.github.io//posts/shu-zhi-diao-zheng-hou-zhi-ye-DPS-mo-ni-DK-ni-xi.html</link>  
		<description>&lt;h3&gt;第一轮数值调整后的DPS模拟，火法跌下神坛，盗贼战士异军突起，DK上演史上最大逆袭&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1376708801189.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376708801189.jpg&#34; title=&#34;Optional title&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1376708819184.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376708819184.jpg&#34; title=&#34;Optional title&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;玩家纷纷表示：居然不用爱疯5也能看到DK的DPS，好顶赞！不过武僧盆友们貌似得去买IP5了…… ，我的冰DK终于逆袭了。哈哈&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-17</pubDate>  
    </item>  
    <item>  
		<title>BAE中web.py上传问题处理</title>  
		<link>http://daimin.github.io//posts/BAE-zhong-web-py-shang-chuan-wen-ti-chu-li.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;这个问题困扰我了两天，在BAE中使用web.py默认的上传方式是不能上传的，通过不懈的努力终于解决了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先你要设置tempfile库的tempdir，BAE文档上面说修改了tempfile的临时目录，但是实际是在web.py中还是使用的系统默认的/tmp/xxx目录，所以首先需要修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bae.core import const

tempfile.tempdir = const.APP_TMPDIR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以放置在app运行之前的代码前，保证其能被设置一次就够了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始我使用的是web.py cookbook中的示例上传代码，文本文件上传是没有问题，但是二进制文件是不行的，无论怎么样多会丢失很多字节，想来应该是BAE修改了python一些库的代码。&lt;/p&gt;
&lt;p&gt;web.py中除了web.input()来获取请求数据外，海油web.data()函数，web.input()是经过&lt;strong&gt;web.py处理过&lt;/strong&gt;的数据的，方便我们使用，而web.data()中获取的就是原本提交的数据。这里的问题就是在web.py的处理的时候，会使二进制数据丢失很多。所以我们来处理web.data()中的数据。&lt;/p&gt;
&lt;p&gt;web.data()中获取的数据就是字符串，可以直接保存为文件，但是还是不能正常使用，因为里面有协议头和其它一些乱七八糟的东西，我们只要中间的entity就OK了。&lt;/p&gt;
&lt;p&gt;前面大概包括空行是4行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------WebKitFormBoundaryecUZ2xK6QjVl5e3K

Content-Disposition: form-data; name=&#34;attac&#34;; filename=&#34;jquery.edatagrid.js&#34;

Content-Type: application/x-javascript
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面是5行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------WebKitFormBoundaryecUZ2xK6QjVl5e3K

Content-Disposition: form-data; name=&#34;name&#34;

pxblog

------WebKitFormBoundaryecUZ2xK6QjVl5e3K--
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok,去掉这几行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d = web.data()

import StringIO

s1 = StringIO.StringIO(d)

s2 = StringIO.StringIO()

lines =  s1.readlines()

lines = lines[4:-5]

s1.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在的lines中就是我们所要的数据了，然后保存起来就是我们所要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实从Content-Disposition中可以得到filename，然后取得文件信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;pic_1376642423074.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/pic_1376642423074.jpg&#34; title=&#34;悲剧&#34; /&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-16</pubDate>  
    </item>  
    <item>  
		<title>css hack的简单使用</title>  
		<link>http://daimin.github.io//posts/css-hack-de-jian-dan-shi-yong.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;pic_1376622770249.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/pic_1376622770249.jpg&#34; title=&#34;IE hack&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天调布局，很是麻烦啊，为毛世界上要有IE这样坑爹的浏览器，而且在TC竟然还占绝大多数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结了几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一种&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;margin-left:-601px; /*所有的浏览器*/

*margin-left:-601px; /*ie6,ie7*/

_margin-left:-601px; /*只有ie6*/

*margin-left:-602px !important; /*只有ie7*/

margin-left:/*\**/:603px\9; /* 所有浏览器IE浏览器 */
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种，利用条件注释语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if IE]&amp;gt;

    此内容只有IE可见

&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if IE 8]&amp;gt;

    只有IE8

&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if !IE 7]&amp;gt;

    除了IE7的IE浏览器

&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if gt IE 7]&amp;gt;

    高于IE7的IE浏览器

&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if lt IE 7]&amp;gt;

    低于IE7的IE浏览器

&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if lte IE 7]&amp;gt;

    低于或等于IE7的IE浏览器

&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-16</pubDate>  
    </item>  
    <item>  
		<title>MYSQL show 命令详解</title>  
		<link>http://daimin.github.io//posts/MYSQL-show-ming-ling-xiang-jie.html</link>  
		<description>&lt;p&gt;&lt;code&gt;show tables或show tables from database_name或show database_name.tables;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示当前数据库中所有表的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show databases;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示mysql中所有数据库的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show processlist;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看&lt;/p&gt;
&lt;p&gt;他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show table status;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show columns from table_name from database_name; 或show columns from database_name.table_name;&lt;/code&gt;或&lt;code&gt;show fields;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解释：显示表中列名称（和 desc table_name 命令的效果是一样的）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show grants for user_name@localhost;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示一个用户的权限，显示结果类似于grant 命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show index from table_name;或show keys;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示表的索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show status;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示一些系统特定资源的信息，例如，正在运行的线程数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show variables;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示系统变量的名称和值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show privileges;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示服务器所支持的不同权限&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show create database database_name;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示创建指定数据库的SQL语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show create table table_name;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示创建指定数据表的SQL语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show engies;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示安装以后可用的存储引擎和默认引擎。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show innodb status;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示innoDB存储引擎的状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show logs;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示BDB存储引擎的日志&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show warnings;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：显示最后一个执行的语句所产生的错误、警告和通知&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show errors;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;解释：只显示最后一个执行语句所产生的错误&lt;/p&gt;
&lt;p&gt;上面的大部分命令都可以用like，比如 &lt;code&gt;show table like ‘%abce%’&lt;/code&gt;  。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-12</pubDate>  
    </item>  
    <item>  
		<title>Python-字符串操作方法(转)</title>  
		<link>http://daimin.github.io//posts/Python-zi-fu-chuan-cao-zuo-fang-fa-zhuan.html</link>  
		<description>&lt;p&gt;&lt;strong&gt;字符串中字符大小写的变换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.lower()   #小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.upper()   #大写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.swapcase()   #大小写互换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.capitalize()   #首字母大写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String.capwords(S) &lt;/p&gt;
&lt;p&gt;#这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.title()    #只有首字母大写，其余为小写，模块中没有这个方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串在输出时的对齐：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.ljust(width,[fillchar]) &lt;/p&gt;
&lt;p&gt;#输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.rjust(width,[fillchar])    #右对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.center(width, [fillchar])    #中间对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.zfill(width)   #把S变成width长，并在右对齐，不足部分用0补足&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串中的搜索和替换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.find(substr, [start, [end]]) &lt;/p&gt;
&lt;p&gt;#返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.index(substr, [start, [end]]) &lt;/p&gt;
&lt;p&gt;#与find()相同，只是在S中没有substr时，会返回一个运行时错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.rfind(substr, [start, [end]]) &lt;/p&gt;
&lt;p&gt;#返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.rindex(substr, [start, [end]])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.count(substr, [start, [end]])    #计算substr在S中出现的次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.replace(oldstr, newstr, [count])  &lt;/p&gt;
&lt;p&gt;#把S中的oldstar替换为newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.strip([chars])&lt;/p&gt;
&lt;p&gt;#把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.lstrip([chars])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.rstrip([chars])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.expandtabs([tabsize]) &lt;/p&gt;
&lt;p&gt;#把S中的tab字符替换没空格，每个tab替换为tabsize个空格，默认是8个&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的分割和组合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.split([sep, [maxsplit]])&lt;/p&gt;
&lt;p&gt;#以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.rsplit([sep, [maxsplit]])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.splitlines([keepends])&lt;/p&gt;
&lt;p&gt;#把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.join(seq) #把seq代表的序列──字符串序列，用S连接起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的mapping，这一功能包含两个函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String.maketrans(from, to)&lt;/p&gt;
&lt;p&gt;#返回一个256个字符组成的翻译表，其中from中的字符被一一对应地转换成to，所以from和to必须是等长的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.translate(table[,deletechars])&lt;/p&gt;
&lt;p&gt;#使用上面的函数产后的翻译表，把S进行翻译，并把deletechars中有的字符删掉。需要注意的是，如果S为unicode字符串，那么就不支持 deletechars参数，可以使用把某个字符翻译为None的方式实现相同的功能。此外还可以使用codecs模块的功能来创建更加功能强大的翻译 表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串还有一对编码和解码的函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.encode([encoding,[errors]])&lt;/p&gt;
&lt;p&gt;#其中encoding可以有多种值，比如gb2312 gbk gb18030 bz2 zlib big5 bzse64等都支持。errors默认值为&#34;strict&#34;，意思是UnicodeError。可能的值还有&#39;ignore&#39;, &#39;replace&#39;, &#39;xmlcharrefreplace&#39;, &#39;backslashreplace&#39; 和所有的通过codecs.register_error注册的值。这一部分内容涉及codecs模块，不是特明白&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.decode([encoding,[errors]])&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的测试函数，这一类函数在string模块中没有，这些函数返回的都是bool值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;S.startwith(prefix[,start[,end]])&lt;/p&gt;
&lt;p&gt;#是否以prefix开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.endwith(suffix[,start[,end]])&lt;/p&gt;
&lt;p&gt;#以suffix结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.isalnum()&lt;/p&gt;
&lt;p&gt;#是否全是字母和数字，并至少有一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.isalpha()  #是否全是字母，并至少有一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.isdigit()  #是否全是数字，并至少有一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.isspace() #是否全是空白字符，并至少有一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.islower() #S中的字母是否全是小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.isupper() #S中的字母是否便是大写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S.istitle() #S是否是首字母大写的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串类型转换函数，这几个函数只在string模块中有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string.atoi(s[,base])&lt;/p&gt;
&lt;p&gt;#base默认为10，如果为0,那么s就可以是012或0x23这种形式的字符串，如果是16那么s就只能是0x23或0X12这种形式的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string.atol(s[,base])  #转成long&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string.atof(s[,base])  #转成float&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-12</pubDate>  
    </item>  
    <item>  
		<title>删除PHP文件中的BOM字符</title>  
		<link>http://daimin.github.io//posts/shan-chu-PHP-wen-jian-zhong-de-BOM-zi-fu.html</link>  
		<description>&lt;p&gt;&lt;code&gt;BOM&lt;/code&gt;是微软搞出来的，比如如果你用windows上面的记事本程序，另存一个文本文件为utf-8编码，那么在文件头就加上了&lt;strong&gt;BOM(0xEF 0xBB 0xBF，即BOM)&lt;/strong&gt;，用来鉴别文件编码格式，但是这在html中就是一行啊，我们在Windows上面写php很容易就加上了BOM。下面是一个脚本，专门用来清除BOM的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

//remove the utf-8 boms

//by magicbug at gmail dot com

if (isset($_GET[&#39;dir&#39;])){ //要去除的文件目录，无参数则为文件当前目录。

$basedir=$_GET[&#39;dir&#39;];

}else{

$basedir = &#39;.&#39;;

}

$auto = 1;

checkdir($basedir);

function checkdir($basedir){

if ($dh = opendir($basedir)) {

   while (($file = readdir($dh)) !== false) {

    if ($file != &#39;.&#39; &amp;amp;&amp;amp; $file != &#39;..&#39;){

     if (!is_dir($basedir.&#34;/&#34;.$file)) {

      echo &#34;filename: $basedir/

$file &#34;.checkBOM(&#34;$basedir/$file&#34;).&#34; &amp;lt;br&amp;gt;&#34;;

     }else{

      $dirname = $basedir.&#34;/&#34;.

$file;

      checkdir($dirname);

     }

    }

   }

closedir($dh);

}

}

function checkBOM ($filename) {

global $auto;

$contents = file_get_contents($filename);

$charset[1] = substr($contents, 0, 1);

$charset[2] = substr($contents, 1, 1);

$charset[3] = substr($contents, 2, 1);

if (ord($charset[1]) == 239 &amp;amp;&amp;amp; ord($charset[2]) == 187 &amp;amp;&amp;amp;

ord($charset[3]) == 191) {

   if ($auto == 1) {

    $rest = substr($contents, 3);

    rewrite ($filename, $rest);

    return (&#34;&amp;lt;font color=red&amp;gt;BOM found,

automatically removed.&amp;lt;/font&amp;gt;&#34;);

   } else {

    return (&#34;&amp;lt;font color=red&amp;gt;BOM found.

&amp;lt;/font&amp;gt;&#34;);

   }

}

else return (&#34;BOM Not Found.&#34;);

}

function rewrite ($filename, $data) {

$filenum = fopen($filename, &#34;w&#34;);

flock($filenum, LOCK_EX);

fwrite($filenum, $data);

fclose($filenum);

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-10</pubDate>  
    </item>  
    <item>  
		<title>豆瓣api的电影信息查询app</title>  
		<link>http://daimin.github.io//posts/dou-ban-api-de-dian-ying-xin-xi-cha-xun.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;其实很简单的的app，就是可以根据关键字查询电影，生成一个电影列表，然后点击列表项里面能显示详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;一，原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;a href=&#34;http://www.douban.com&#34;&gt;豆瓣&lt;/a&gt;的api，现在是v2版本了，可以从&lt;a href=&#34;http://developers.douban.com/wiki/?title=api_v2&#34;&gt;这里&lt;/a&gt;查看详细。需要注意的是必须设置&lt;code&gt;User-Agent&lt;/code&gt;这个请求头，否则返回的就是500错误了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  httpGet.setHeader(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.22 (KHTML,     like Gecko) Chrome/25.0.1364.172 Safari/537.22&#34;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至于android那边我用的HttpClient，这个很简单的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String uString= Douban.HOST + &#34;search?q=&#34; + ch + &#34;&amp;amp;start=&#34; + off + &#34;&amp;amp;count=&#34; +   Douban.PAGE_SIZE;

HttpGet httpGet = new HttpGet(uString);

HttpParams httpParams = new BasicHttpParams();

HttpConnectionParams.setConnectionTimeout(httpParams,

         Douban.NET_TIME_OUT);

HttpConnectionParams.setSoTimeout(httpParams,

     Douban.NET_TIME_OUT);

httpGet.setParams(httpParams);

//X，竟然要模仿浏览器

httpGet.setHeader(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.22 (KHTML, like         Gecko) Chrome/25.0.1364.172 Safari/537.22&#34;);

HttpClient httpclient = new DefaultHttpClient();

HttpResponse response = httpclient.execute(httpGet);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;android3.0以后就不能从主线程中访问网络了，否则就会抛出一个异常&lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;，而且是&lt;code&gt;RuntimeException&lt;/code&gt;，需要注意，可以用Handler或者是AsyncTask来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片的下载也是，因为图片的下载肯定也是异步的，所以不能在当前网络线程中访问，更不能在主线程里面处理，最好再起一个线程，这里推荐&lt;code&gt;AsyncTask&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public class ImageLoader extends AsyncTask&amp;lt;Integer, Integer, String&amp;gt; {

    private ImageView imgView;

    private String url = null;

    private Bitmap bm = null;

    public ImageLoader(ImageView imgView, String url) {

        super();

        this.imgView = imgView;

        this.url = url;

    }

    @Override

    protected String doInBackground(Integer... arg0) {

        InputStream is = null;

        URL aryURI = null;

        try {

            aryURI = new URL(url);

            is = aryURI.openStream();

            bm = BitmapFactory.decodeStream(is);

        } catch (MalformedURLException e) {

            e.printStackTrace();

        } catch (IOException e) {

            e.printStackTrace();

        }finally{

            try {

                is.close();

            } catch (IOException e) {

                e.printStackTrace();

            }

        }

        return null;

    }

    @Override

    protected void onPostExecute(String result) {

        this.imgView.setImageBitmap(bm);

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有很多的不完善之处，比如图片的缓存处理，甚至是JSON数据的缓存处理，还有推出后恢复现场的处理，而且还可以接入douban更多的接口，UI也不是很好看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以从&lt;a href=&#34;http://vagascanner.googlecode.com/files/FDouBan.zip&#34;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-09</pubDate>  
    </item>  
    <item>  
		<title>Nginx 常用配置</title>  
		<link>http://daimin.github.io//posts/Nginx-chang-yong-pei-zhi.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;用Nginx做Web服务器，如果没有处理好日志，日志文件可能会很恐怖~10G、20G&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以修改nginx.conf 找到access_log：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    access_log /dev/null;

    error_log /dev/null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样全部把他们丢到系统的黑洞里了&lt;/p&gt;
&lt;p&gt;不用每时每刻都往系统磁盘疯狂的读写日志了 还延长硬盘的寿命&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查配置 &lt;code&gt;/usr/local/webserver/nginx/sbin/nginx -t&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启nginx和php-fpm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/php-fpm restart

killall -v nginx ; service nginx start
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载配置 &lt;code&gt;/usr/local/nginx/sbin/nginx -s reload&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是反向代理获得真实IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先在代理配置中加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    proxy_set_header        Host $host;

    proxy_set_header        X-Real-IP $remote_addr;

    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，重载配置，可以从$_SERVER[&#39;HTTP_X_REAL_IP&#39;] 和 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]获取真实IP如果是服务器是Nginx，可以直接去，如果是Apache需要安装apache的一个第三方模块&#34;mod_rpaf&#34;了, 官方网站: http://stderr.net/apache/rpaf/。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用fcgi_cache来减少CPU压力&lt;pre&gt;&lt;code&gt;fastcgi_cache_path /data/ngx_fcgi_tmp  levels=1:2  keys_zone=cache_php:30m inactive=1d                max_size=10g;

fastcgi_cache   cache_php;

fastcgi_cache_valid   200 302  1h;

fastcgi_cache_min_uses  1;

fastcgi_cache_use_stale error  timeout invalid_header http_500;

fastcgi_cache_key $host$request_uri;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fastcgi_cache_path：fastcgi_cache&lt;/code&gt;缓存目录，可以设置目录层级，比如1:2会生成16*256个字目录，cache_php是这个缓存空间的名字，cache是用多少内存（这样热门的内容nginx直接放内存，提高访问速度），inactive表示默认失效时间，max_size表示最多用多少硬盘空间。本来还有个fastcgi_temp_path参数，但发现似乎没用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*  `fastcgi_cache_valid`：定义哪些http头要缓存

*  `fastcgi_cache_min_uses`：URL经过多少次请求将被缓存

*  `fastcgi_cache_use_stale`：定义哪些情况下用过期缓存

*  `fastcgi_cache_key`：定义fastcgi_cache的key，示例中就以请求的URI作为缓存的key，Nginx会取这个key的md5作为缓存文件，如果设置了缓存哈希目录，Nginx会从后往前取相应的位数做为目录

*  `fastcgi_cache`：用哪个缓存空间
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;nginx 禁止IP访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {

        listen       80 default_server;

        return       500;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止指定文件类型的访问 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location ~ /.*\.pem {

        deny all;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-09</pubDate>  
    </item>  
    <item>  
		<title>博客换了新的主题了</title>  
		<link>http://daimin.github.io//posts/bo-ke-huan-le-xin-de-zhu-ti-le.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;终于将新的主题换了上去，不过好像还没有之前的顺眼，但是之前的主题不适合内容展示，所以没办法，只能换一个了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;后台还是一如之前的简单，没有列表，只有一个添加和编辑页面。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;准备加入:&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * 草稿功能
 * 图片上传功能
&lt;/code&gt;&lt;/pre&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-08</pubDate>  
    </item>  
    <item>  
		<title>PHP数组的插入顺序</title>  
		<link>http://daimin.github.io//posts/PHP-shu-zu-de-cha-ru-shun-xu.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;这个问题，纠结了我2个小时，一直的找bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其实就是以为php数组如果是整形键值的话，会自动的按数值的从大到小排序，其实呢，人家php才不管它的key是什么，它都一视同仁，不管是数值还是字符串都是按照插入顺序的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是的，其实php的数组更像是map，但是它又维持着插入顺序，好吧，主要是自己想当然的，记在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;罪魁祸首就是它：&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function _fillEmptyPaytype($paytypes){

    foreach($this-&amp;gt;PAY_TYPES as $pk=&amp;gt;$pv){

        if(!isset($paytypes[$pk])){

           $paytypes[$pk] = &#39;0.00&#39;;

        }

    }

    ksort($paytypes);

    return $paytypes;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上，加上&lt;strong&gt;ksort&lt;/strong&gt;就可以了。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-07</pubDate>  
    </item>  
    <item>  
		<title>Nginx中一个server配置多个location</title>  
		<link>http://daimin.github.io//posts/Nginx-zhong-yi-ge-server-pei-zhi-duo-ge.html</link>  
		<description>&lt;h5&gt;nginx中的location的匹配规则是“先匹配正则，再匹配普通”，同级的就是先后顺序了。&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;我这里需要实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个server中配置两个location对应不同的root目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个location分别对应不同的phpfpm代理的location配置  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个特定的url使用一个别名，这里要用别名，不要用root，alias指定的目录是准确的，root是指定目录的上级目录 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  location /texasholdem/bug/ {

       alias /data1/www/texasholdem/bug/;

       index  index.php index.html index.htm ;

  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定域名的配置  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; location / {

     root   /data1/www/wp/;

     index  index.php index.html index.htm ;

 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应特定的url的phpfpm配置，注意root的值，root就是document_root&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为就上文来说document_root就是/data1/www/，这里不能用alias。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     location ~ /texasholdem/bug/(.*)\.php$ {

        root           /data1/www/;

        fastcgi_pass   127.0.0.1:9000;

        fastcgi_index  index.php;

        fastcgi_intercept_errors on;

        fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;

        include        fastcgi_params;

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;域名的php配置，只要配置相同的root就行了。&lt;pre&gt;&lt;code&gt;location ~ \.php$ {

    root           /data1/www/wp/;

    fastcgi_pass   127.0.0.1:9000;

    fastcgi_index  index.php;

    fastcgi_intercept_errors on;

    fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;

    include        fastcgi_params;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>新增了一个相册</title>  
		<link>http://daimin.github.io//posts/xin-zeng-le-yi-ge-xiang-ce.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;里面都是GF的图片，为此她埋怨我了不少，哈哈。可以通过 &lt;a href=&#34;http://codecos.com/photo/&#34;&gt;这里&lt;/a&gt;访问&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其实还可以点击rss图标旁边的图标访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这个相册里面的图片是放在&lt;a href=&#34;http://qiniu.com&#34;&gt;七牛云存储&lt;/a&gt;上面的，这里小小的给它打个广告，真心不错，免费配额也是挺多的，而且提供的SDK也挺方便使用，速度也挺不错，推荐下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相册是使用的&lt;a href=&#34;http://www.marcofolio.net/webdesign/creating_a_polaroid_photo_viewer_with_css3_and_jquery.html&#34;&gt;polaroid photo viewer&lt;/a&gt;，只需要简单的引入css和JS后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后就是&lt;a href=&#34;http://www.lokeshdhakar.com/projects/lightbox2/&#34;&gt;lightbox2&lt;/a&gt;了，这个很简单了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;之前百度一直不收录，买了个&lt;a href=&#34;http://codecos.com&#34;&gt;域名&lt;/a&gt;，可是让我肉痛了几下，准备多学学SEO的知识了，这个就当作学习成本吧，哈哈。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>最近准备干啥</title>  
		<link>http://daimin.github.io//posts/zui-jin-zhun-bei-gan-sha.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;想练一练Java，具体来说是Android，预备是两个：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;豆瓣的电影搜索，以前做过一部分，不过很丑，而且现在它的API升级了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于本博客的Android客户端，其实就是一个写博客的工具而已，很简单的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>Nginx中alias和root的区别(转)</title>  
		<link>http://daimin.github.io//posts/Nginx-zhong-alias-he-root-de-qu-bie-zhuan.html</link>  
		<description>&lt;p&gt;nginx貌似没有虚拟目录的说法，因为它本来就是完完全全根据目录来设计并工作的。&lt;/p&gt;
&lt;p&gt;如果非要给nginx安上一个虚拟目录的说法，那就只有alias标签比较“像”，干脆来说说alias标签和root标签的区别吧。&lt;/p&gt;
&lt;p&gt;最基本的区别：alias指定的目录是准确的，root是指定目录的上级目录，并且该上级目录要含有location指定名称的同名目录。使用alias标签的目录块中不能使用rewrite的break。&lt;/p&gt;
&lt;p&gt;说不明白，看下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {

    alias /home/html/abc/;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段配置下，http://test/abc/a.html 就指定的是 /home/html/abc/a.html。这段配置亦可改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {

    root /home/html/;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，nginx就会去找/home/html/目录下的abc目录了，得到的结果是相同的。&lt;/p&gt;
&lt;p&gt;但是，如果我把alias的配置改成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {

    alias /home/html/def/;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么nginx将会从/home/html/def/取数据，这段配置还不能直接使用root配置，如果非要配置，只有在/home/html/下建立一个 def-&amp;gt;abc的软link（快捷方式）了。&lt;/p&gt;
&lt;p&gt;一般情况下，在location /中配置root，在location /other中配置alias是一个好习惯。&lt;/p&gt;
&lt;p&gt;至于alias和root的区别，我估计还没有说完全，如果在配置时发现奇异问题，不妨把这两者换换试试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文链接：nginx 虚拟目录？的配置[http://www.sudone.com/nginx/nginx_alias.html]&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-01</pubDate>  
    </item>  
    <item>  
		<title>netbeans英文字体修改</title>  
		<link>http://daimin.github.io//posts/netbeans-ying-wen-zi-ti-xiu-gai.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;JDK_HOME/jre/lib&lt;/code&gt; 目录下的&lt;code&gt;fontconfig.properties.src&lt;/code&gt;复制一份文件&lt;code&gt;fontconfig.properties&lt;/code&gt;，并放在该目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑文件&lt;code&gt;fontconfig.properties&lt;/code&gt;，查找到下面一行：  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;sequence.monospaced.GBK=chinese-ms936, alphabetic,dingbats,symbol&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;可以发现由于中文&lt;strong&gt;monospaced&lt;/strong&gt;字体缺省查找顺序是先使用&lt;strong&gt;chinese-ms936&lt;/strong&gt;，结果造成了英文被宋体来          显示。纠正非常简单，只需将&lt;strong&gt;chinese-ms936&lt;/strong&gt;和&lt;strong&gt;alphabetic&lt;/strong&gt;调换顺序就可以了： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;sequence.monospaced.GBK=alphabetic,chinese-ms936,dingbats,symbol&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google开始收录这个博客了，可是百度还说我没有添加网站。法克！&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-07-31</pubDate>  
    </item>  
    <item>  
		<title>修改博客的编辑器为Markdown</title>  
		<link>http://daimin.github.io//posts/xiu-gai-bo-ke-de-bian-ji-qi-wei.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;采用的是&lt;a href=&#34;http://oscargodson.github.io/EpicEditor/&#34;&gt;EpicEditor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语法链接在上面有，其实挺简单的，比KindEditor来说，虽然功能上面肯定要弱很多，但是很能激发起写作的欲望，以后多在这里写一些东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本博客的github地址为：&lt;a href=&#34;https://github.com/daimin/tolog&#34;&gt;https://github.com/daimin/tolog&lt;/a&gt;，欢迎过来提意见&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;其实我觉得用了markdown以后文章的标题好像成了鸡肋了。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-07-30</pubDate>  
    </item>  
    <item>  
		<title>留言板</title>  
		<link>http://daimin.github.io//posts/liu-yan-ban.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这个网站部署在github上面，用python生成的静态页面，用mako作为模板引擎，使用markdown来写作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里记录自己的心情日志，技术分享等。有什么探讨的请留言给我。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;世上除了生死，都是小事。从现在开始，每天微笑吧。不管遇到了什么烦心事，都不要自己为难自己；无论今天发生多么糟糕的事，都不应该感到悲伤。今天是你往后日子里最年轻的一天了，因为有明天，今天永远只是起跑线。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记住一句话：越努力，越幸运。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-02-12</pubDate>  
    </item>  
    <item>  
		<title>jVaga，蛋疼的JS库</title>  
		<link>http://daimin.github.io//posts/jVaga-dan-teng-de-JS-ku.html</link>  
		<description>&lt;p&gt;很简单的，没多少代码，应该还有很多BUG，先做个标记在这里。&lt;/p&gt;
&lt;p&gt;我的目标就是 &lt;strong&gt;Make you easy use&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主要就是模仿Jquery的使用，肯定没有jquery强大，但是肯定也要简单许多。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;能使用jVaga.extend进行对象扩展(prototype.js)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能进行简单的浏览器类型判断，jVaga.B，如果是IE则会返回IE版本号，如果是其它浏览器只会是布尔值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能使用jVaga()或者$，进行元素选择，你也可以使用jVaga.util.setNamespace自定义选择器标志符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择器返回的是包装后的JS对象，你可以直接调用它提供的各种便利的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;选择器用法：



    &amp;lt;!DOCTYPE html&amp;gt;

    &amp;lt;html lang=&#34;cn&#34;&amp;gt;

    &amp;lt;head&amp;gt;

    &amp;lt;meta charset=&#34;utf-8&#34; /&amp;gt;

    &amp;lt;script type=&#34;text/javascript&#34; src=&#34;jvaga-0.3.0.js&#34;&amp;gt;&amp;lt;/script&amp;gt;

     &amp;lt;script type=&#34;text/javascript&#34;&amp;gt;

    /*        window.onload = function(){

                    var dd = document.getElementById(&#34;track&#34;);

                    alert(dd.getAttribute);

              }

     */

               $(function(){



     // test1 : 命名空间设置

     //             jVaga.util.setNamespace(&#34;$_$&#34;);

     //             alert($_$(&#34;#track&#34;));

     // test : id

     //             alert($(&#34;#track&#34;));

     /*$(&#34;.logo&#34;).each(function(e){

       alert(e.hasClass(&#34;logo1&#34;));

     });

     */

     // class 选择，class检测, find二次选择，属性值获取,tagName选择

     //alert($(&#34;.logo&#34;)[0].hasClass(&#34;logo&#34;));

     //alert($(&#34;.logo&#34;)[0].find(&#34;img&#34;)[0].attr(&#39;src&#39;));

     //alert($(&#34;a&#34;)[0].text());

     // 链式使用

     //alert($(&#34;.logo&#34;)[0].find(&#34;img&#34;)[0].attr(&#39;src&#39;,&#39;xxxx.gif&#39;).attr(&#39;src&#39;));

     // $(&#34;#ddd&#34;) $(&#34;[name=&#39;sds&#39;]:first &amp;gt; &#34;) $(&#34;input&#34;)

     // 浏览器测试

     //alert($.B.IE);

     //alert($.B.OP);

     //alert($.B.WK);

     //alert($.B.GK);

     //alert($.B.MS);



               });

             &amp;lt;/script&amp;gt;

         &amp;lt;/head&amp;gt;

         &amp;lt;body&amp;gt;



           &amp;lt;div class=&#34;header&#34;&amp;gt;

               &amp;lt;div class=&#34;logo&#34;&amp;gt;&amp;lt;img src=&#34;images/logo.png&#34; /&amp;gt;&amp;lt;/div&amp;gt;

               &amp;lt;div id=&#34;track&#34;&amp;gt;

                &amp;lt;a href=&#34;#&#34;&amp;gt;首页&amp;lt;/a&amp;gt;

                &amp;lt;span class=&#34;arrow&#34;&amp;gt;&amp;amp;gt;&amp;amp;gt;&amp;lt;/span&amp;gt;

                绘图优化

             &amp;lt;/div&amp;gt;

           &amp;lt;/div&amp;gt;

          &amp;lt;div id=&#34;main&#34;&amp;gt;

           &amp;lt;div class=&#34;blocks&#34;&amp;gt;



             &amp;lt;div id=&#34;leaveBlank&#34;&amp;gt;

                想象力的留白

           &amp;lt;/div&amp;gt;



         &amp;lt;div class=&#34;block&#34;&amp;gt;

              &amp;lt;div id=&#34;userInfo&#34;&amp;gt;

                  &amp;lt;h3&amp;gt;个人信息&amp;lt;/h3&amp;gt;

                 &amp;lt;img src=&#34;images/userhead.jpg&#34;&amp;gt;

              &amp;lt;/div&amp;gt;

           &amp;lt;/div&amp;gt;

               &amp;lt;div class=&#34;article&#34;&amp;gt;

               &amp;lt;div class=&#34;title&#34;&amp;gt;

                   &amp;lt;div class=&#34;title_cont&#34;&amp;gt;

                       我的文章标题

                   &amp;lt;/div&amp;gt;

                   &amp;lt;div class=&#34;tag&#34;&amp;gt;

                       标签1 标签2

                   &amp;lt;/div&amp;gt;

               &amp;lt;/div&amp;gt;

          &amp;lt;/div&amp;gt;



         &amp;lt;/body&amp;gt;

     &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jVaga.util下面有各种的工具函数，如：  &lt;/p&gt;
&lt;p&gt;toArray函数将参数转换成数组；addClass2TagNext给指定的标签的元素的下一个元素节点运用class；&lt;/p&gt;
&lt;p&gt;loadScript函数动态加载JS包；getEvent函数，兼容浏览器的Event对象的获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给数组类型加入了each函数，能方便的遍历每个元素；给String加入了trim函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了便利的Ajax支持，（为提供效率，使用了HttpRequest对象连接池，不知道是不是好的实践呢？）jVaga.Post对应post方式的AJax请求，jVaga.get就是get方式的了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以自由的使用该工具，但是本人不保证其效率及功能的完整性，如果能有任何的反馈，我会很乐意的修改，如果你能将该工具用于任何的项目中，我也十分的荣幸，不过请保留本人的名字。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;一不小心就0.3.1版本了，主要做了如下修改：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这个版本主要对于节点选择器内部实现的改进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单来说，因为IE8+及Chrome、Safari、Firefox比较新的版本中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;都实现了比较好的选择器querySelector及querySelectorAll，这些选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比我用Javascript实现的选择器，效率不知高多少倍，所以我在内部需要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适配使用该接口实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只是针对Css ClassName的选择的时候，应用了querySelectorAll,其它的情况下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也是无法应用该接口&lt;/p&gt;
&lt;p&gt;而用法还是如上面，所示：  &lt;/p&gt;
&lt;p&gt;新版本的代码在&lt;a href=&#34;http://vagascanner.googlecode.com/files/jvaga-0.3.1.js&#34;&gt;这里下载&lt;/a&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2011-07-12</pubDate>  
    </item>  
</channel>  
</rss>  
