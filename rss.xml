<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
    <title>茶瓯葱丝</title>  
    <link>blog.codecos.com</link>  
	<description>本站内容为个人技术博客及其它软件编程信息。本站采用python开发，用markdown来进行编辑，生成静态文本放在github上。</description>  
    <language>zh-cn</language>  
    <generator>sologd</generator>  
    <item>  
		<title>留言板</title>  
		<link>http://blog.codecos.com//posts/liu-yan-ban.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;这个网站部署在github上面，用python生成的静态页面，用mako作为模板引擎，使用markdown来写作。+ 这里记录自己的心情日志，技术分享等。有什么探讨的请留言给我。&amp;gt; 世上除了生死，都是小事。从现在开始，每天微笑吧。不管遇到了什么烦心事，都不要自己为难自己；无论今天发生多么糟糕的事，都不应该感到悲伤。今天是你往后日子里最年轻的一天了，因为有明天，今天永远只是起跑线。 &amp;gt;&amp;gt; 记住一句话：越努力，越幸运。&lt;/li&gt;
&lt;/ul&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2014-02-12</pubDate>  
    </item>  
    <item>  
		<title>使用RSA在Java端私钥加密，PHP端公钥验证</title>  
		<link>http://blog.codecos.com//posts/shi-yong-RSA-zai-Java-duan-si-yao-jia-mi-PHP-duan-gong-yao-yan-zheng.html</link>  
		<description>&lt;p&gt;工作需要研究下RSA加密解密算法，一不小心差点把自己搞疯了，主要是我们服务器是PHP，而客户端肯定以后是Java了。所以我需要的是在Java端用私钥加密，而服务器用公钥进行验证。在这两端进行RSA加密解密需要严格的要求，这里我主要做一下记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先是Java端：&lt;/strong&gt;   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用的是javax.crypto.Cipher库，一般来说最好使用这个库，因为Android里面也带有这个库，而且使用起来比较方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成私钥公钥对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&#34;RSA&#34;);     
//密钥位数     
keyPairGen.initialize(1024);     
//密钥对     
KeyPair keyPair = keyPairGen.generateKeyPair();

// 公钥     
PublicKey publicKey = (RSAPublicKey) keyPair.getPublic();

// 私钥     
PrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取私钥，使用PKCS8EncodedKeySpec来生成，Base64库最好使用org.apache.commons.codec4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;byte[] keyBytes;     
keyBytes = Base64.decodeBase64(key);

PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);

KeyFactory keyFactory = KeyFactory.getInstance(&#34;RSA&#34;);     
PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里需要注意的是获取instance的时候必须是&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;，否则php是不支持pkcs8的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cipher cipher = Cipher.getInstance(&#34;RSA/ECB/PKCS1Padding&#34;);
cipher.init(Cipher.DECRYPT_MODE, ppkey);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;好像加密的时候，好像不能一次性对超过117个字节的数据加密，可以做如下的处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;byte[] enBytes = null;
int i = 0;
for (i = 0; i &amp;lt; ptext.length; i += 64) {  
      // 注意要使用2的倍数，否则会出现加密后的内容再解密时为乱码
      byte[] doFinal = cipher.doFinal(ArrayUtils.subarray(ptext, i,i + 64));  
      enBytes = ArrayUtils.addAll(enBytes, doFinal);  
}
return enBytes;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意的是这里加密的话，最好对原文进行MD5之后，在加密，那么在PHP端，进行验证的时候，只要验证原文的MD5值就行了，因为PHP的openssl对于比较长的字符串，好像并不能进行处理，Java没有此问题。&lt;strong&gt;就是这里困了我好久&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;服务器PHP端&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保存公钥，放到文件中，还是数据库中随便，不过需要注意的是Java中的公钥、私钥只有字符串就OK，但是PHP中的是有指定格式的，必须这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCFtYP+8zOR2WPJe/0c0w3kf3vmzcDksDPFgaqI
psR+587tPm5YgZc53ii90wXsmjwVedU8yM8aZYpg7ZZALAximTR/JnK3A/+ffQG7lmNM0zC9StsD
S3rD9bNIj0jGHUBT5Dxf98+TnEojWECeg5ZibZ51xzN8tChqB7MmApBIGwIDAQAB
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过下面的函数处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function setupPubKey($pubkey) {
    if (is_resource ( $pubKey )) {
        return true;
    }

    $pem = chunk_split($pubkey,64,&#34;\n&#34;);
    $pem = &#34;-----BEGIN PUBLIC KEY-----\n&#34;.$pem.&#34;-----END PUBLIC KEY-----\n&#34;;
    $pubkey = openssl_pkey_get_public ( $pem );
    return $pubkey;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意的是，这里验证的是原文的md5值，这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$result = (bool)openssl_verfify(md5($plainText),base64_decode($sign), OPENSSL_ALGO_DSS1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须使用OPENSSL_ALGO_DSS1，我也不知道为什么，估计是和&lt;strong&gt;RSA/ECB/PKCS1Padding&lt;/strong&gt;对应，
不过在使用alipay或者     wandoujia进行签名验证的时候，可能不需要这个参数，请酌情增、删。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这个东西话费了我很多时间才调通，差点放弃，语言间对于RSA的实现会有所不同，描述也会有所不同。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-11-23</pubDate>  
    </item>  
    <item>  
		<title>走着走着，花就开了</title>  
		<link>http://blog.codecos.com//posts/zou-zhao-zou-zhao-hua-jiu-kai-le.html</link>  
		<description>&lt;p&gt;优柔寡断，是人生最大的负能量。&lt;/p&gt;
&lt;p&gt;人生没什么好优柔的。&lt;/p&gt;
&lt;p&gt;从生命角度去看，你人生路径上的任何一种选择都是错误的，无论你怎么选，都有差错；&lt;/p&gt;
&lt;p&gt;因此，当选择来临，A和B，拿一个便走就是。&lt;/p&gt;
&lt;p&gt;人生没有对错，只有选择后的坚持，不后悔，走下去，就是对的。&lt;/p&gt;
&lt;p&gt;我最喜欢的一句诗就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;走着走着，花就开了。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-11-08</pubDate>  
    </item>  
    <item>  
		<title>自省和计划</title>  
		<link>http://blog.codecos.com//posts/zi-sheng-he-ji-hua.html</link>  
		<description>&lt;h6&gt;技术上会的东西&lt;/h6&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;java: java基本语法熟练，熟悉android、javaweb开发，SSH框架之类的都忘记了。&lt;/li&gt;
&lt;li&gt;php: php语法熟练，能使用纯php构建web系统，codeigniter和thinkphp框架熟悉。&lt;/li&gt;
&lt;li&gt;python: python语法熟悉，web.py熟悉，django学习中，了解pyqt开发。&lt;/li&gt;
&lt;li&gt;JS相关: javascript掌握,jquery熟悉，能开发nodejs程序。&lt;/li&gt;
&lt;li&gt;数据库：比较熟悉的就只有mysql了。&lt;/li&gt;
&lt;li&gt;linux常用命令的使用，系统环境搭建，简单的系统维护都能做。&lt;/li&gt;
&lt;li&gt;其它：html、css都熟悉，除了不会做美术设计，其它的基本都OK了。c/c++也算了解，能做简单的开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h5&gt;接下来的该学的&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;python的django框架&lt;/li&gt;
&lt;li&gt;了解计算机网络知识&lt;/li&gt;
&lt;li&gt;操作系统知识&lt;/li&gt;
&lt;li&gt;数据结构和算法的知识&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;除了django外，其它都是一些计算机基本知识了，学过这么多样的东西，其实真没必要再去学其它的具体开发技术了，如果还想做几年程序，计算机的基本知识和理论才是重要的，当然我也没那么偏激去学高等数学什么的。加油吧!&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-10-10</pubDate>  
    </item>  
    <item>  
		<title>一个非常非常简单的markdown编辑器</title>  
		<link>http://blog.codecos.com//posts/yi-ge-fei-chang-fei-chang-jian-dan-de-markdown-bian-ji-qi.html</link>  
		<description>&lt;p&gt;之前一直使用&lt;em&gt;markdownPad&lt;/em&gt;，功能是很强大，但是那个速度我就不想吐槽了，其实我只需要一个非常简单的markdown编辑器，只要简单的预览就够了，所以就有了这个markdown的编辑器。你可以在&lt;a href=&#34;https://github.com/daimin/mdchick&#34;&gt;这里&lt;/a&gt;得到它的源码。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;简单的介绍：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为我的&lt;a href=&#34;http://codecos.com&#34;&gt;博客&lt;/a&gt;是用python写的，所以其markdown也是用的python的库进行解析的，然后大多数的md的编辑器都和博客使用的库的解析结果有所不同，包括markdownPad，只是它稍微好些而已，所以我就想自己用python来做一款简单的markdown的编辑器，这样写起博客来，就非常顺畅了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑器使用&lt;a href=&#34;http://www.riverbankcomputing.co.uk/software/pyqt/download/&#34;&gt;pyqt4&lt;/a&gt;来编写，为什么不用qt?因为我不会，而且我要的是python的程序，这样才能最好的和博客一致。pyqt应该是python中最强大的UI库之一吧，很好用，文档多，而且很多的示例，强烈推荐之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在编辑器的功能只有编辑和预览的功能，后续应该会有&lt;strong&gt;加粗&lt;/strong&gt;，&lt;strong&gt;斜体&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;插入代码块&lt;/strong&gt;，再加上nodepad的功能，不会更多了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;已经加上了&lt;strong&gt;加粗&lt;/strong&gt;，&lt;strong&gt;斜体&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;插入代码块&lt;/strong&gt;，等一些简单的功能。如果感兴趣，请参考&lt;a href=&#34;https://github.com/daimin/mdchick&#34;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天晚上要回家了，开心，激动，嘎嘎！&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-25</pubDate>  
    </item>  
    <item>  
		<title>用python进行博客的迁移</title>  
		<link>http://blog.codecos.com//posts/yong-python-jin-xing-bo-ke-de-qian-yi.html</link>  
		<description>&lt;p&gt;今天将原来的博客的博文全部移植到了 &lt;a href=&#34;codecos.com&#34;&gt;codecos&lt;/a&gt; 上面，其实blogjava.net里面有功能的，它是导出为xml，可是我看导出后的xml，解析起来，还要比直接解析html麻烦些，所以还是用python写了一个抓取的脚本。&lt;/p&gt;
&lt;p&gt;脚本的功能用到了多线程、urllib2进行GET请求，urllib2、urllib1、cookielib进行POST请求，BeautifulSoup对html数据进行分析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从我原来的博客 &lt;a href=&#34;http://www.blogjava.net/vagasnail&#34;&gt;http://www.blogjava.net/vagasnail&lt;/a&gt;中抓取数据，用的urllib2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;req = urllib2.Request(self.url)
response = urllib2.urlopen(req)
the_page = response.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于开始使用单线程，很慢啊，基本上不能运行成功，不得已使用了多行程的方式，每一个url的抓取、解析数据和向目标博客POST数据都会启动一个新的线程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 建立线程类从threading.Thread继承
class FetchThread(threading.Thread):
    def run(self):
        # 这个函数是必须实现的，其实和JAVA中的Thread类是如此的像
        # 线程实际运行就是这个函数
        pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用的解析库是BeautifulSoup，这个非常好用啊。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;soup = BeautifulSoup(data)
#拿到所有的链接
alinks =  soup.find_all(&#39;a&#39;)
#正则表达式，因为不是所有的链接都有用的
pattern1 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/articles/[0-9]+\.html$&#39;)
pattern2 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/archive/[0-9]{4}/[0-9]{2}/[0-9]{2}/[0-9]+\.html$&#39;)
pattern3 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/category/[0-9]+\.html$&#39;)
pattern4 = re.compile(r&#39;^http://www.blogjava.net/vagasnail/archive/[0-9]{4}/[0-9]{2}\.html$&#39;)
#拿到标题，标题是ID标识的
title = soup.find_all(id=&#34;viewpost1_TitleUrl&#34;)
#只要文本数据就行了
art[&#39;title&#39;] = title[0].get_text()
#拿到内容
content = soup.find_all(&#39;div&#39;, class_=&#34;postbody&#34;)
#内容应该所有HTML字符
art[&#39;content&#39;] = str(content[0])
#发布日期是直接作为普通的文本节点在里面的，没办法只能用正则了
re.M表示多行模式
pattern_date = re.compile(r&#39;([0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2})&#39;,re.M)
#必须要用findall它会查询字符串中匹配模式的所有子字符串
pdates = pattern_date.findall(str_postfoot)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就是POST到&lt;a href=&#34;codecos.com&#34;&gt;目标博客&lt;/a&gt;了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#引入要用的库
import urllib,urllib2,cookielib

cj = cookielib.CookieJar()
#处理POST数据的URL
b_url =&#39;http://codecos.com/****&#39;
art[&#39;tag&#39;] = &#34;,&#34;.join(art[&#39;tag&#39;])
#art是列表这里把它转成元组
body = art.items()
#设置cookie
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
#模拟浏览器请求
opener.addheaders = [(&#39;User-agent&#39;,
    &#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#39;)]
urllib2.install_opener(opener)
#发送请求
req = urllib2.Request(b_url, urllib.urlencode(body))
u = urllib2.urlopen(req)
u.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所以&lt;a href=&#34;codecos.com&#34;&gt;我的博客&lt;/a&gt;现在的已经有很多文章了，不过有些还是样式有些问题，只能手动调整了。
还有这些不是用&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;markdown&lt;/a&gt;写的，改起来很麻烦啊，所有还是&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;markdown&lt;/a&gt;舒服啊。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-14</pubDate>  
    </item>  
    <item>  
		<title>PHP+Mysql+Sphinx(coreseek)站内搜索引擎的搭建</title>  
		<link>http://blog.codecos.com//posts/PHP-Mysql-Sphinx-coreseek-zhan-nei-sou-suo-yin-qing-de-da-jian.html</link>  
		<description>&lt;p&gt;后台搜索速度越来越慢，考虑着用专业的搜索工具。 &lt;br /&gt;
Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。 它提供php,java,ruby,python等多种语言的api。
我这里使用的是coreseek，Coreseek为应用提供全文检索功能，目前的版本（2.x 3.x）基于Sphinx 0.9.8，支持使用Python定义数据源，支持中文分词。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载安装coreseek，在这里&lt;a href=&#34;http://www.coreseek.cn/uploads/csft/4.0/coreseek-4.1-win32.zip&#34;&gt;下载&lt;/a&gt;coreseek最新版4.1。下载后直接解压就行了。比如说 D:\coreseek-4.1-win32。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改etc目录下面的 csft_mysql.conf文件。首先是数据源定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#数据源定义
source mysql
    {
        type                    = mysql

        sql_host                = localhost
        sql_user                = root
        sql_pass                = 
        sql_db                  = 
        sql_port                = 3306
        sql_query_pre           = SET NAMES utf8

        sql_query = SELECT id, group_id, type, UNIX_TIMESTAMP(date_added) AS date_added, title, content FROM documents

        sql_attr_uint    = group_id 
        sql_attr_timestamp  =  date_added

        sql_query_info_pre      = SET NAMES utf8                                        
        sql_query_info          = SELECT * FROM payinfo WHERE id=$id
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;type: 数据库类型，目前支持 mysql 与 pgsql &lt;/li&gt;
&lt;li&gt;sql_host、sql_user、sql_pass、sql_port: mysql数据库的相关配置&lt;/li&gt;
&lt;li&gt;sql_query_pre： 索引数据获取前执行的查询，这里用来设置字符集&lt;/li&gt;
&lt;li&gt;sql_query: 全文检索要显示的内容，在这里尽可能不使用where或 group by，将 where 与 groupby 的内容交给 sphinx，由 sphinx 进行条件过滤与 groupby 效率会更高&lt;/li&gt;
&lt;li&gt;sql_attr_*: 表示一些属性字段，你原计划要用在 where, orderby, groupby 中的字段要在这里定义&lt;/li&gt;
&lt;li&gt;sql_query_info： 文档信息查询。 可选选项，默认为空。 仅对 mysql 数据源有效。&lt;/li&gt;
&lt;li&gt;sql_query_info_pre： 命令行查询前查询。 可选选项，默认为空。 仅对 mysql 数据源有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#index定义
index mysql
{
    source            = mysql
    path            = var/data/mysql
    docinfo            = extern
    mlock            = 0
    morphology        = none
    min_word_len        = 1
    html_strip                = 0
    charset_dictpath = etc/                             #Windows环境下设置，/符号结尾，最好给出绝对路径，例如：C:/usr/local/coreseek/etc/...
    charset_type        = zh_cn.utf-8
    enable_star = 1
    min_infix_len = 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;source 源名称&lt;/li&gt;
&lt;li&gt;path 索引记录存放目录，如 d:/sphinx/data/cgfinal ,实际存放时会存放在 d:/sphinx/data 目录，然后创建多个 cgfinal 名称，不同扩展名的索引文件。&lt;/li&gt;
&lt;li&gt;docinfo: 文档信息(docinfo)的存储模式。可选选项，默认是“extern”，可用的值包括&#39;none&#39;, &#39;extern&#39; 和 &#39;inline&#39;。&lt;/li&gt;
&lt;li&gt;min_word_len: 最小索引词长度。可选选项，默认为1（索引任何词）。只有长度不小于这个最小索引词长度的词会被索引。&lt;/li&gt;
&lt;li&gt;charset_type: 字符集编码类型。可选选项，默认为“sbcs”。可用的值包括“sbcs”和“utf-8”。 对于使用Coreseek的中文用户，可选的值还可以有“zh_cn.utf-8 ”、“zh_cn.gbk”和“zh_cn.big5”（需要编译时提供iconv支持）。当设置charset_type值为上面的值时，系统默认您开启了中文分词特性。&lt;/li&gt;
&lt;li&gt;charset_dictpath: 设置中文分词词典所在的目录，默认是mmseg3&lt;/li&gt;
&lt;li&gt;enable_star: 允许前缀/中缀索引上的星号语法（或称通配符）。可选选项，默认为0（不使用通配符）。可用值为1或者0。所有关键字都根据索引时的 min_prefix_len 和 min_infix_len settings设置被视为前缀或者中缀。如&lt;em&gt;da&lt;/em&gt;, *dai&lt;/li&gt;
&lt;li&gt;min_infix_len：索引的最小中缀长度。可选选项，默认为0（不索引中缀）。&lt;/li&gt;
&lt;li&gt;min_prefix_len：索引的最小前缀长度。可选选项，默认为0（不索引前缀）。&lt;/li&gt;
&lt;li&gt;前缀和中缀不能同时索引。索引了前缀和中缀会使索引慢很多，请斟酌。&lt;/li&gt;
&lt;li&gt;其它的参数请参见 &lt;a href=&#34;http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#conf-min-infix-len&#34;&gt;Coreseek 4.1 参考手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局索引定义 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#全局index定义
indexer
{
    mem_limit            = 128M
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;mem_limit 索引使用内存最大限制，根据机器情况而定，默认是32M，太小的会影响索引的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;searchd服务定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;searchd
{
    listen                  =   9312
    read_timeout        = 5
    max_children        = 30
    max_matches            = 1000
    seamless_rotate        = 0
    preopen_indexes        = 0
    unlink_old            = 1
    pid_file = var/log/searchd_mysql.pid  #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
    log = var/log/searchd_mysql.log        #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
    query_log = var/log/query_mysql.log #请修改为实际使用的绝对路径，例如：/usr/local/coreseek/var/...
    binlog_path =                                #关闭binlog日志
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这个不多，请参见手册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成索引并启动后台&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\coreseek-4.1-win32&amp;gt;bin\indexer -c etc\csft_mysql.conf --all
# 索引配置中定义的所有索引。
D:\coreseek-4.1-win32&amp;gt;bin\searchd -c etc\csft_mysql.conf --console
# 运行检索守护进程
# 另外打开一个CMD窗口，然后：
D:\coreseek-4.1-win32&amp;gt;bin\search -c etc\csft_mysql.conf -a 100
# 查询所有包含100的文档。注意这里的需要考虑的分词规则，100成功，可能10就不会成功。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;php客户端使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require ( &#34;sphinxapi.php&#34; );
# sphinx提供的PHP客户端。
$cl = new SphinxClient ();
$cl-&amp;gt;SetServer(&#39;127.0.0.1&#39;, 9312);
$cl-&amp;gt;SetConnectTimeout ( 3 );
$cl-&amp;gt;SetArrayResult ( true );
$cl-&amp;gt;SetMatchMode ( SPH_MATCH_EXTENDED);
$res = $cl-&amp;gt;Query ( &#39;all&#39;, &#34;*&#34; );
print_r($res[&#39;matches&#39;]);
# 连接到searchd服务器，根据服务器的当前设置执行给定的查询(搜索所有的索引中包含all)，取得并返回结果集。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;只是一个简单的记录，主要是自己备忘。详细的使用方式，参见 &lt;a href=&#34;http://www.coreseek.cn/docs/coreseek_4.1-sphinx_2.0.1-beta.html#conf-min-infix-len&#34;&gt;Coreseek 4.1 参考手册&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-09-10</pubDate>  
    </item>  
    <item>  
		<title>Nginx+uWsgi+web.py 搭建与简单测试</title>  
		<link>http://blog.codecos.com//posts/Nginx-uWsgi-web-py-da-jian-yu-jian-dan-ce-shi.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;Nginx + uWsgi + web.py 效率真是不错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装uWsgi  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是下载 &lt;a href=&#34;http://projects.unbit.it/downloads/uwsgi-1.9.14.tar.gz&#34;&gt;http://projects.unbit.it/downloads/uwsgi-1.9.14.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解压 &lt;code&gt;sudo python setup.py build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装 &lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx和web.py的安装就不多说&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
  include uwsgi_params;
  #uwsgi_pass 127.0.0.1:9002;
  #对应uwsgi.ini配置的socket文件
  uwsgi_pass unix:/tmp/uwsgi.sock;
}
#静态文件访问
location /static/ {
  if (-f $request_filename) {
    rewrite ^/static/(.*)$  /static/$1 break;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于web.py的脚本index.py&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import web

urls = (&#34;/.*&#34;, &#34;hello&#34;)
app = web.application(urls, globals())

class hello:
    def GET(self):
        return &#39;Hello, world!&#39;

#if __name__ == &#34;__main__&#34;: #注意将改行注释掉
application = app.wsgifunc()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uWsgi的配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[uwsgi]
#socket = 127.0.0.1:9002
#用socket文件方式
socket = /tmp/uwsgi.sock
chdir = /data/www/webpy/
processes = 8
threads = 2
master = true
module = index
;pidfile = /data/uwsgi-bin/uwsgi.pid
;listen = 128
#守护进程方式运行，并指明日志文件
daemonize = /data/www/webpy/uwsgi.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意chdir指向程序目录，module是主运行文件，见上，加入pidfile后好像对性能有影响，所以这里注释掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;sudo uwsgi uwsgi.ini&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;br /&gt;
   测试使用的是apache的ab工具。&lt;code&gt;ab -n1000 -c100 http://192.168.1.1:8080/&lt;/code&gt;，结果如下： &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377586380417.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377586380417.gif&#34; title=&#34;web.py&#34; /&gt;&lt;/p&gt;
&lt;p&gt;拿php来测试下，同样的服务器,同样的nginx，使用的是nginx + php-fpm fastcgi的模式。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377586409480.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377586409480.gif&#34; title=&#34;php&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看得出比PHP还是快了不少&lt;/strong&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-27</pubDate>  
    </item>  
    <item>  
		<title>BAE中文编码引起的程序崩溃</title>  
		<link>http://blog.codecos.com//posts/BAE-zhong-wen-bian-ma-yin-qi-de-cheng-xu-beng-kui.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;qiniu_1377505253074.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377505253074.jpg&#34; title=&#34;python&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我的博客修改了一些东西，主要是中文编码问题，在自己的机器上面是没有问题的。只是在BAE上面会有问题，而且这个问题又不是每次都出现，所以很纠结，查看了很久的日志&lt;em&gt;因为日志查询真的很慢啊，有木有啊&lt;/em&gt;，在&lt;code&gt;index.py&lt;/code&gt;中加上了如下的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置系统的默认编码。
可以去github上面下载相关的代码：&lt;a href=&#34;https://github.com/daimin/tolog&#34;&gt;https://github.com/daimin/tolog&lt;/a&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-26</pubDate>  
    </item>  
    <item>  
		<title>mysql 用法备忘</title>  
		<link>http://blog.codecos.com//posts/mysql-yong-fa-bei-wang.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;工作中一直都用mysql，遇到一些问题，需要查来查去，下一次遇到相同的又忘记，又要查，很不方便啊，这次记在这里，备查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1377507698298.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377507698298.jpg&#34; title=&#34;mysql&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Alter语句用法   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改列的类型信息 &lt;br /&gt;
ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称（这里可以用和原来列同名即可）】 BIGINT NOT NULL  COMMENT &#39;注释说明&#39;&lt;/li&gt;
&lt;li&gt;重命名列 &lt;br /&gt;
ALTER TABLE 【表名字】 CHANGE 【列名称】【新列名称】 BIGINT NOT NULL  COMMENT &#39;注释说明&#39;&lt;/li&gt;
&lt;li&gt;重命名表 &lt;br /&gt;
ALTER TABLE 【表名字】 RENAME 【表新名字】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示运行线程和杀死线程   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show processlist;
kill connection threadid;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;replace into&lt;/code&gt; 会修改具有相同键的数据行的所有列的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导出查询结果到文件   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT id,dbname FROM `index` into outfile &#34;d://aaa.txt&#34;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改表的默认字符集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;&lt;/code&gt; 转换表及所有字符字段的字符集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql添加用户 &lt;br /&gt;
&lt;strong&gt;好吧BAE不让我录入下面的sql语句，我读进行过滤了的啊，坑啊，难怪那么慢，过滤了多少东西啊，无力吐槽，图片看你怎么过滤！！！&lt;/strong&gt;
   &lt;img alt=&#34;qiniu_1377508847990.gif&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1377508847990.gif&#34; title=&#34;mysql&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定mysql服务到指定IP
    命令行启动时，使用 &lt;br /&gt;
&lt;code&gt;/usr/local/mysql/bin/mysqld_safe --bind-address=127.0.0.1&lt;/code&gt; 即可。&lt;br /&gt;
    如果需要修改服务脚本，编辑/etc/init.d/mysqld，找到第330行，将此内容：
&lt;code&gt;$bindir/mysqld_safe --datadir=$datadir --pid-file=$server_pid_file $other_args&lt;/code&gt; &lt;br /&gt;
修改为： &lt;br /&gt;
&lt;code&gt;$bindir/mysqld_safe --datadir=$datadir --pid-file=$server_pid_file --bind-address=127.0.0.1 $other_args&lt;/code&gt;
即可。&lt;br /&gt;
    启动服务后，使用netstat -nat|grep 3306可以看到服务只绑定在127.0.0.1上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distinct 和 group by  &lt;br /&gt;
   这两种语句其实都差不都，distinct使用起来会方便些，group by 在加了索引后效率会高一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DATE_FORMAT 函数用法 &lt;br /&gt;
    DATE_FORMAT(paytime, &#39;%Y-%m-%d&#39;)，这里paytime是待格式化的日期，%Y就是年，%m月，%d日，很简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert和select&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;replace into temp(`username`,`date`) select username,DATE_FORMAT(paytime, &#39;%Y-%m-%d&#39;) as paydate from pay_detail where `paytime`&amp;lt;=&#39;2013-08-25 23：59：59&#39; and `paytime`&amp;gt;=&#39;2013-07-26 00：00：00&#39; group by username
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;以后遇到新的问题，还会增加在这里。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-26</pubDate>  
    </item>  
    <item>  
		<title>在BAE上面搭建基于web.py的博客（一）</title>  
		<link>http://blog.codecos.com//posts/zai-BAE-shang-mian-da-jian-ji-yu-web-py-de-bo-ke-yi.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;下载安装python，我这里安装的是python2.6.5。你可以从&lt;a href=&#34;http://www.python.org/getit/&#34;&gt;这里&lt;/a&gt;下载安装，我使用的系统是windowsxp。你只要下载相应的版本了。然后点击安装就可以了。&lt;/li&gt;
&lt;li&gt;下载web.py，从&lt;a href=&#34;http://webpy.org/install&#34;&gt;这里&lt;/a&gt;下载，对于web.py我没有安装，直接放置到工程木下面而已。你可以解压压缩包，然后运行&lt;code&gt;python setup.py install&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我使用的开发工具的pydev，这是一个eclipse的python开发插件，如果你感觉卡，可以调整eclipse.ini的-Xms，默认好像是40m，可以到-Xms256m。&lt;/li&gt;
&lt;li&gt;模板引擎，web.py自带有一个模板引擎，但是功能较弱，而且运行速度也不怎么样，我最开始也是使用的这个引擎，但是用起来有很多局限性，我这里推荐&lt;a href=&#34;http://www.makotemplates.org/&#34;&gt;mako&lt;/a&gt;，这个引擎的速度号称是python里面最快的模板引擎了，具体我也没有验证过，不过确实好用，确定就是文档比较少，不过你还是可以在网上找到一些资料，如：&lt;a href=&#34;http://www.cnblogs.com/RChen/archive/2007/06/15/mako_doc_translation_2.html&#34;&gt;http://www.cnblogs.com/RChen/archive/2007/06/15/mako_doc_translation_2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关于前端页面，你可以自己写一套，你也可以去拿一套现存的，你不知道哪里有？wordpress那么多好看的主题，难道不是吗？找到你心仪的主题，然后很快的用web.py改成你自己的网站，岂不是很爽。不过不要忘记加上主题的作者信息。&lt;/li&gt;
&lt;li&gt;使用markdown进行写作，比如我现在写的这篇文件就是用markdown写的，&lt;a href=&#34;https://pypi.python.org/pypi/Markdown&#34;&gt;python的markdown处理包&lt;/a&gt;，下载对应你的python版本的包。&lt;/li&gt;
&lt;li&gt;BAE百度的人品之作，速度不错，免费配额也不错，Python支持也不错，比起国外的还要靠谱很多。 &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最简单的helloworld。你可以在&lt;a href=&#34;http://webpy.org/cookbook/helloworld.zh-cn&#34;&gt;web.py cookbook&lt;/a&gt;上面找到。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import web

urls = (&#34;/.*&#34;, &#34;hello&#34;)
app = web.application(urls, globals())

class hello:
    def GET(self):
        return &#39;Hello, world!&#39;

if __name__ == &#34;__main__&#34;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭建我们的博客&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用pydev建立一个工程就OK了，假定该工程为&lt;strong&gt;demo&lt;/strong&gt;，然后将&lt;strong&gt;web.py的包文件夹&lt;/strong&gt;，&lt;strong&gt;mako的包文件夹&lt;/strong&gt;,&lt;strong&gt;markdown包文件夹&lt;/strong&gt;，拷贝到该工程下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在工程根目录建立文件夹templates,建立静态文件夹static，默认static目录中的文件，可以通过URL直接访问，当然这是在你本地，如果是在BAE上面就需要写处理脚本了，当然你也可以放在其它的服务器上面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义urls&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;urls = (
   r&#39;/(\d*)&#39;, &#39;Index&#39;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url采用的一个url的正则匹配一个逻辑处理类，我这里称之为handler。
   (\d*)对应了Index的GET或POST方法的出self参数外的第一个参数。
   注意url配置，要用r前缀，表示不对正则中的\进行转义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3个root变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app_root = os.path.dirname(__file__)
templates_root = os.path.join(app_root, &#39;templates/&#39; + conf.theme)
static_root = os.path.join(app_root, &#39;static&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义mako的模板渲染器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;render = render_mako(
    templates_root,
    input_encoding=&#39;utf-8&#39;,
    output_encoding=&#39;utf-8&#39;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义一个基类，因为业务中，我们有很多都是相同的，那么我们就放在基类中进行处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Base():
    def __init__(self):
        self._conf = conf.site
        #do what you want.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义Index类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Index(Base):
    def __init__(self):
        Base.__init__(self)#必须调用基类的构造函数

    def GET(self, page):
        self.say = &#34;Hello World&#34;
        return render.index(page=self)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在子类的构造函数中必须要调用基类的构造函数，web.py中用GET方法处理客户端的get请求，对应的POST方法处理post请求，GET和POST方法中的处理第一个参数外的参数，都是对应url中的捕获组中的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;render.index&lt;/code&gt;中的index表示一个模板文件，其中的参数是可以在模板中直接访问的，如果是web.py的模板，就需要$def with (page)后才可以使用，mako中可以直接使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;p&gt;本机就这样运行，然后在浏览器中输入localhost:8080，就可以访问了，8080可以修改为你绑定的端口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;web.config.debug = True
app = web.application(urls, globals())
app.notfound = errNotFound
if __name__ == &#34;__main__&#34;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是在BAE上面就是这样，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = web.application(urls, globals()).wsgifunc()

from bae.core.wsgi import WSGIApplication
application = WSGIApplication(app)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后还要在BAE上面注意的是&lt;strong&gt;修改app.conf的handler&lt;/strong&gt;加上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- url : /(\d*)
script : index.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;之后还要着重的介绍一下BAE的使用。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;有什么不对的地方还请留言指正，大家一起学习。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-23</pubDate>  
    </item>  
    <item>  
		<title>用Python发垃圾邮件</title>  
		<link>http://blog.codecos.com//posts/yong-Python-fa-la-ji-you-jian.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;qiniu_1376907717364.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376907717364.jpg&#34; title=&#34;解析页面发邮件&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个程序写了很久了，是刚开始学习python的时候写的，主要就是抓取页面的邮箱，然后发送。直接看代码吧，是我少有的注释比较详细的代码了，希望会有点参考价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding:UTF-8 -*-   
#encoding=utf-8
#author:daimin(vagasnail#gmail.com)
&#34;&#34;&#34;
  1 能发送到多个邮箱
  2 使用多线程
  3 抓取指定的网页得到网页中的邮箱，然后发送(通过命令行参数获取网页地址)
&#34;&#34;&#34;
import sys
import smtplib
from email.Message import Message  
from time import sleep
import threading
import urllib2,urllib
from BeautifulSoup import BeautifulSoup
from BeautifulSoup import BeautifulStoneSoup
import re


to_addrs = [&#39;target@xx.com&#39;]       #目标邮箱
cc_addr = &#39;cc@xx.com&#39;              #抄送  
from_addr = &#39;from@xxx.com&#39;         #发送邮箱

# 标题和正文
    subject = u&#39;这不是垃圾邮件&#39; # u表示该字符使用unicode方式编码，注意这里只是起指示作用，用于一些函数处理
    content = u&#39;你好，测试用的&#39;

    class MyThread(threading.Thread):
    # const
    smtpserver = &#39;smtp.gmail.com&#39;  
    username = &#39;vagasnail@gmail.com&#39;  
    password = &#39;dai253685&#39;


    def __init__(self,no,msg,to_addr):
        threading.Thread.__init__(self) # 调用parent的__init__方法
        self.no = no
        self.msg = msg
        self.to_addr = to_addr

    def run(self):
        self.send_message()

    def send_message(self):
        print &#34; start thread %d ....\n&#34; % (self.no)
        sm = smtplib.SMTP(MyThread.smtpserver, port=587, timeout=20)  
        sm.set_debuglevel(1)                   #开启debug模式   
        sm.ehlo()  
        sm.starttls()                          #使用安全连接   
        sm.ehlo()  
        sm.login(MyThread.username, MyThread.password)

        sm.sendmail(from_addr, self.to_addr, self.msg)  
        sleep(5)  
        sm.quit()

# 使用urllib2 获取html文档
# 使用BeautifulSoup解析html文档        
def get_to_addrs(url):
    #pattern = re.compile(r&#39;^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$&#39;)
    pattern = re.compile(r&#39;\w+[\.\w]+@\w+\.\w+&#39;)
    global to_addrs
    req = urllib2.Request(url)
    res = urllib2.urlopen(req, timeout=10)
    html = res.read()
    res.close()

    match = pattern.findall(html)
    to_addrs.extend(match)
    #soup = BeautifulStoneSoup(html)
    &#39;&#39;&#39;
    ass = soup.findAll(&#34;a&#34;)
    for a in ass:
        h = a.get(&#39;href&#39;)
        if h &amp;lt;&amp;gt; None:
            h = h.strip()
            pos = h.find(tag)
            if pos &amp;lt;&amp;gt; -1:
                mail = h.replace(tag,&#39;&#39;)
                mail = mail.strip()
                to_addrs.append(mail)
    &#39;&#39;&#39;

if __name__ == &#34;__main__&#34;: 
    &#34;&#34;&#34;
因为解码是python自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。
很多情况下 sys.defaultencoding 是 ANSCII，如果 s 不是这个类型就会出错。
拿上面的情况来说，我的 sys.defaultencoding 是 anscii，而 s 的编码方式和文件的编码方式一致，是 utf8 的。
你可以明确的s.decode(xxx).encode(xxxx)来编码解码 (解码：将编码解释为字符串，编码：将字符串编码)
    &#34;&#34;&#34;
    reload(sys)  # Python2.5 初始化后会删除 sys.setdefaultencoding 这个方法，我们需要重新载入
    sys.setdefaultencoding( &#34;utf-8&#34; )

    if len(sys.argv) &amp;lt;&amp;gt; 2:
        print &#34;    Please input target page&#39;s url which you want handle!&#34;
        exit(0)

    url = sys.argv[1]
    get_to_addrs(url)
    print to_addrs

    tno = 1
    for to_addr in to_addrs:
        message = Message()
        #message.set_charset(&#39;&#39;)


        message[&#39;Subject&#39;] = subject    #邮件标题   
        message[&#39;From&#39;] = from_addr
        message[&#39;To&#39;] = to_addr   
        message[&#39;Cc&#39;] = cc_addr   
        message.set_payload(content)    #邮件正文   
        msg = message.as_string() 
        #send_message(tno,msg,to_addr)        
        t = MyThread(tno,msg,to_addr)
        t.start()
        tno = tno + 1
&lt;/code&gt;&lt;/pre&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-19</pubDate>  
    </item>  
    <item>  
		<title>数值调整后职业DPS模拟 DK逆袭</title>  
		<link>http://blog.codecos.com//posts/shu-zhi-diao-zheng-hou-zhi-ye-DPS-mo-ni-DK-ni-xi.html</link>  
		<description>&lt;h3&gt;第一轮数值调整后的DPS模拟，火法跌下神坛，盗贼战士异军突起，DK上演史上最大逆袭&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1376708801189.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376708801189.jpg&#34; title=&#34;Optional title&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;qiniu_1376708819184.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/qiniu_1376708819184.jpg&#34; title=&#34;Optional title&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;玩家纷纷表示：居然不用爱疯5也能看到DK的DPS，好顶赞！不过武僧盆友们貌似得去买IP5了…… ，我的冰DK终于逆袭了。哈哈&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-17</pubDate>  
    </item>  
    <item>  
		<title>BAE中web.py上传问题处理</title>  
		<link>http://blog.codecos.com//posts/BAE-zhong-web-py-shang-chuan-wen-ti-chu-li.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;这个问题困扰我了两天，在BAE中使用web.py默认的上传方式是不能上传的，通过不懈的努力终于解决了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先你要设置tempfile库的tempdir，BAE文档上面说修改了tempfile的临时目录，但是实际是在web.py中还是使用的系统默认的/tmp/xxx目录，所以首先需要修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from bae.core import const
tempfile.tempdir = const.APP_TMPDIR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以放置在app运行之前的代码前，保证其能被设置一次就够了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始我使用的是web.py cookbook中的示例上传代码，文本文件上传是没有问题，但是二进制文件是不行的，无论怎么样多会丢失很多字节，想来应该是BAE修改了python一些库的代码。&lt;/p&gt;
&lt;p&gt;web.py中除了web.input()来获取请求数据外，海油web.data()函数，web.input()是经过&lt;strong&gt;web.py处理过&lt;/strong&gt;的数据的，方便我们使用，而web.data()中获取的就是原本提交的数据。这里的问题就是在web.py的处理的时候，会使二进制数据丢失很多。所以我们来处理web.data()中的数据。&lt;/p&gt;
&lt;p&gt;web.data()中获取的数据就是字符串，可以直接保存为文件，但是还是不能正常使用，因为里面有协议头和其它一些乱七八糟的东西，我们只要中间的entity就OK了。&lt;/p&gt;
&lt;p&gt;前面大概包括空行是4行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------WebKitFormBoundaryecUZ2xK6QjVl5e3K
Content-Disposition: form-data; name=&#34;attac&#34;; filename=&#34;jquery.edatagrid.js&#34;
Content-Type: application/x-javascript
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面是5行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------WebKitFormBoundaryecUZ2xK6QjVl5e3K
Content-Disposition: form-data; name=&#34;name&#34;

pxblog
------WebKitFormBoundaryecUZ2xK6QjVl5e3K--
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ok,去掉这几行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d = web.data()
import StringIO
s1 = StringIO.StringIO(d)
s2 = StringIO.StringIO()
lines =  s1.readlines()
lines = lines[4:-5]
s1.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在的lines中就是我们所要的数据了，然后保存起来就是我们所要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实从Content-Disposition中可以得到filename，然后取得文件信息。
&lt;img alt=&#34;pic_1376642423074.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/pic_1376642423074.jpg&#34; title=&#34;悲剧&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-16</pubDate>  
    </item>  
    <item>  
		<title>css hack的简单使用</title>  
		<link>http://blog.codecos.com//posts/css-hack-de-jian-dan-shi-yong.html</link>  
		<description>&lt;p&gt;&lt;img alt=&#34;pic_1376622770249.jpg&#34; src=&#34;http://vaga-static.qiniudn.com/pic_1376622770249.jpg&#34; title=&#34;IE hack&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天调布局，很是麻烦啊，为毛世界上要有IE这样坑爹的浏览器，而且在TC竟然还占绝大多数。
总结了几点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一种&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;margin-left:-601px; /*所有的浏览器*/
*margin-left:-601px; /*ie6,ie7*/
_margin-left:-601px; /*只有ie6*/
*margin-left:-602px !important; /*只有ie7*/
margin-left:/*\**/:603px\9; /* 所有浏览器IE浏览器 */
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种，利用条件注释语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if IE]&amp;gt;
    此内容只有IE可见 
&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if IE 8]&amp;gt;
    只有IE8
&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if !IE 7]&amp;gt;
    除了IE7的IE浏览器
&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if gt IE 7]&amp;gt;
    高于IE7的IE浏览器
&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if lt IE 7]&amp;gt;
    低于IE7的IE浏览器
&amp;lt;![endif]--&amp;gt;

&amp;lt;!--[if lte IE 7]&amp;gt;
    低于或等于IE7的IE浏览器
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-16</pubDate>  
    </item>  
    <item>  
		<title>MYSQL show 命令详解</title>  
		<link>http://blog.codecos.com//posts/MYSQL-show-ming-ling-xiang-jie.html</link>  
		<description>&lt;p&gt;&lt;code&gt;show tables或show tables from database_name或show database_name.tables;&lt;/code&gt;&lt;br /&gt;
解释：显示当前数据库中所有表的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show databases;&lt;/code&gt;&lt;br /&gt;
解释：显示mysql中所有数据库的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show processlist;&lt;/code&gt;&lt;br /&gt;
解释：显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看
他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show table status;&lt;/code&gt;&lt;br /&gt;
解释：显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show columns from table_name from database_name; 或show columns from database_name.table_name;&lt;/code&gt;或&lt;code&gt;show fields;&lt;/code&gt;
解释：显示表中列名称（和 desc table_name 命令的效果是一样的）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show grants for user_name@localhost;&lt;/code&gt;&lt;br /&gt;
解释：显示一个用户的权限，显示结果类似于grant 命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show index from table_name;或show keys;&lt;/code&gt;&lt;br /&gt;
解释：显示表的索引&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show status;&lt;/code&gt;&lt;br /&gt;
解释：显示一些系统特定资源的信息，例如，正在运行的线程数量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show variables;&lt;/code&gt;&lt;br /&gt;
解释：显示系统变量的名称和值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show privileges;&lt;/code&gt;&lt;br /&gt;
解释：显示服务器所支持的不同权限&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show create database database_name;&lt;/code&gt;&lt;br /&gt;
解释：显示创建指定数据库的SQL语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show create table table_name;&lt;/code&gt;&lt;br /&gt;
解释：显示创建指定数据表的SQL语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show engies;&lt;/code&gt;&lt;br /&gt;
解释：显示安装以后可用的存储引擎和默认引擎。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show innodb status;&lt;/code&gt;&lt;br /&gt;
解释：显示innoDB存储引擎的状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show logs;&lt;/code&gt;&lt;br /&gt;
解释：显示BDB存储引擎的日志&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show warnings;&lt;/code&gt;&lt;br /&gt;
解释：显示最后一个执行的语句所产生的错误、警告和通知&lt;/p&gt;
&lt;p&gt;&lt;code&gt;show errors;&lt;/code&gt;&lt;br /&gt;
解释：只显示最后一个执行语句所产生的错误&lt;/p&gt;
&lt;p&gt;上面的大部分命令都可以用like，比如 &lt;code&gt;show table like ‘%abce%’&lt;/code&gt;  。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-12</pubDate>  
    </item>  
    <item>  
		<title>Python-字符串操作方法(转)</title>  
		<link>http://blog.codecos.com//posts/Python-zi-fu-chuan-cao-zuo-fang-fa-zhuan.html</link>  
		<description>&lt;p&gt;&lt;strong&gt;字符串中字符大小写的变换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.lower()   #小写&lt;/li&gt;
&lt;li&gt;S.upper()   #大写&lt;/li&gt;
&lt;li&gt;S.swapcase()   #大小写互换&lt;/li&gt;
&lt;li&gt;S.capitalize()   #首字母大写&lt;/li&gt;
&lt;li&gt;String.capwords(S) 
      #这是模块中的方法。它把S用split()函数分开，然后用capitalize()把首字母变成大写，最后用join()合并到一起&lt;/li&gt;
&lt;li&gt;S.title()    #只有首字母大写，其余为小写，模块中没有这个方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串在输出时的对齐：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.ljust(width,[fillchar]) 
      #输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。&lt;/li&gt;
&lt;li&gt;S.rjust(width,[fillchar])    #右对齐&lt;/li&gt;
&lt;li&gt;S.center(width, [fillchar])    #中间对齐&lt;/li&gt;
&lt;li&gt;S.zfill(width)   #把S变成width长，并在右对齐，不足部分用0补足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串中的搜索和替换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.find(substr, [start, [end]]) 
      #返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索&lt;/li&gt;
&lt;li&gt;S.index(substr, [start, [end]]) 
      #与find()相同，只是在S中没有substr时，会返回一个运行时错误&lt;/li&gt;
&lt;li&gt;S.rfind(substr, [start, [end]]) 
      #返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号&lt;/li&gt;
&lt;li&gt;S.rindex(substr, [start, [end]])&lt;/li&gt;
&lt;li&gt;S.count(substr, [start, [end]])    #计算substr在S中出现的次数&lt;/li&gt;
&lt;li&gt;S.replace(oldstr, newstr, [count])&lt;br /&gt;
      #把S中的oldstar替换为newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换&lt;/li&gt;
&lt;li&gt;S.strip([chars])
      #把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None&lt;/li&gt;
&lt;li&gt;S.lstrip([chars])&lt;/li&gt;
&lt;li&gt;S.rstrip([chars])&lt;/li&gt;
&lt;li&gt;S.expandtabs([tabsize]) 
      #把S中的tab字符替换没空格，每个tab替换为tabsize个空格，默认是8个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的分割和组合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.split([sep, [maxsplit]])
      #以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符&lt;/li&gt;
&lt;li&gt;S.rsplit([sep, [maxsplit]])&lt;/li&gt;
&lt;li&gt;S.splitlines([keepends])
      #把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符。&lt;/li&gt;
&lt;li&gt;S.join(seq) #把seq代表的序列──字符串序列，用S连接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的mapping，这一功能包含两个函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String.maketrans(from, to)
      #返回一个256个字符组成的翻译表，其中from中的字符被一一对应地转换成to，所以from和to必须是等长的。&lt;/li&gt;
&lt;li&gt;S.translate(table[,deletechars])
      #使用上面的函数产后的翻译表，把S进行翻译，并把deletechars中有的字符删掉。需要注意的是，如果S为unicode字符串，那么就不支持 deletechars参数，可以使用把某个字符翻译为None的方式实现相同的功能。此外还可以使用codecs模块的功能来创建更加功能强大的翻译 表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串还有一对编码和解码的函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.encode([encoding,[errors]])
      #其中encoding可以有多种值，比如gb2312 gbk gb18030 bz2 zlib big5 bzse64等都支持。errors默认值为&#34;strict&#34;，意思是UnicodeError。可能的值还有&#39;ignore&#39;, &#39;replace&#39;, &#39;xmlcharrefreplace&#39;, &#39;backslashreplace&#39; 和所有的通过codecs.register_error注册的值。这一部分内容涉及codecs模块，不是特明白&lt;/li&gt;
&lt;li&gt;S.decode([encoding,[errors]])&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串的测试函数，这一类函数在string模块中没有，这些函数返回的都是bool值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S.startwith(prefix[,start[,end]])
      #是否以prefix开头&lt;/li&gt;
&lt;li&gt;S.endwith(suffix[,start[,end]])
      #以suffix结尾&lt;/li&gt;
&lt;li&gt;S.isalnum()
      #是否全是字母和数字，并至少有一个字符&lt;/li&gt;
&lt;li&gt;S.isalpha()  #是否全是字母，并至少有一个字符&lt;/li&gt;
&lt;li&gt;S.isdigit()  #是否全是数字，并至少有一个字符&lt;/li&gt;
&lt;li&gt;S.isspace() #是否全是空白字符，并至少有一个字符&lt;/li&gt;
&lt;li&gt;S.islower() #S中的字母是否全是小写&lt;/li&gt;
&lt;li&gt;S.isupper() #S中的字母是否便是大写&lt;/li&gt;
&lt;li&gt;S.istitle() #S是否是首字母大写的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字符串类型转换函数，这几个函数只在string模块中有：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string.atoi(s[,base])
      #base默认为10，如果为0,那么s就可以是012或0x23这种形式的字符串，如果是16那么s就只能是0x23或0X12这种形式的字符串&lt;/li&gt;
&lt;li&gt;string.atol(s[,base])  #转成long&lt;/li&gt;
&lt;li&gt;string.atof(s[,base])  #转成float&lt;/li&gt;
&lt;/ul&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-12</pubDate>  
    </item>  
    <item>  
		<title>删除PHP文件中的BOM字符</title>  
		<link>http://blog.codecos.com//posts/shan-chu-PHP-wen-jian-zhong-de-BOM-zi-fu.html</link>  
		<description>&lt;p&gt;&lt;code&gt;BOM&lt;/code&gt;是微软搞出来的，比如如果你用windows上面的记事本程序，另存一个文本文件为utf-8编码，那么在文件头就加上了&lt;strong&gt;BOM(0xEF 0xBB 0xBF，即BOM)&lt;/strong&gt;，用来鉴别文件编码格式，但是这在html中就是一行啊，我们在Windows上面写php很容易就加上了BOM。下面是一个脚本，专门用来清除BOM的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//remove the utf-8 boms
//by magicbug at gmail dot com
if (isset($_GET[&#39;dir&#39;])){ //要去除的文件目录，无参数则为文件当前目录。
$basedir=$_GET[&#39;dir&#39;];
}else{
$basedir = &#39;.&#39;;
}
$auto = 1;
checkdir($basedir);
function checkdir($basedir){
if ($dh = opendir($basedir)) {
   while (($file = readdir($dh)) !== false) {
    if ($file != &#39;.&#39; &amp;amp;&amp;amp; $file != &#39;..&#39;){
     if (!is_dir($basedir.&#34;/&#34;.$file)) {
      echo &#34;filename: $basedir/
$file &#34;.checkBOM(&#34;$basedir/$file&#34;).&#34; &amp;lt;br&amp;gt;&#34;;
     }else{
      $dirname = $basedir.&#34;/&#34;.
$file;
      checkdir($dirname);
     }
    }
   }
closedir($dh);
}
}
function checkBOM ($filename) {
global $auto;
$contents = file_get_contents($filename);
$charset[1] = substr($contents, 0, 1);
$charset[2] = substr($contents, 1, 1);
$charset[3] = substr($contents, 2, 1);
if (ord($charset[1]) == 239 &amp;amp;&amp;amp; ord($charset[2]) == 187 &amp;amp;&amp;amp;
ord($charset[3]) == 191) {
   if ($auto == 1) {
    $rest = substr($contents, 3);
    rewrite ($filename, $rest);
    return (&#34;&amp;lt;font color=red&amp;gt;BOM found,
automatically removed.&amp;lt;/font&amp;gt;&#34;);
   } else {
    return (&#34;&amp;lt;font color=red&amp;gt;BOM found.
&amp;lt;/font&amp;gt;&#34;);
   }
}
else return (&#34;BOM Not Found.&#34;);
}
function rewrite ($filename, $data) {
$filenum = fopen($filename, &#34;w&#34;);
flock($filenum, LOCK_EX);
fwrite($filenum, $data);
fclose($filenum);
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-10</pubDate>  
    </item>  
    <item>  
		<title>豆瓣api的电影信息查询app</title>  
		<link>http://blog.codecos.com//posts/dou-ban-api-de-dian-ying-xin-xi-cha-xun.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;其实很简单的的app，就是可以根据关键字查询电影，生成一个电影列表，然后点击列表项里面能显示详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;一，原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;a href=&#34;http://www.douban.com&#34;&gt;豆瓣&lt;/a&gt;的api，现在是v2版本了，可以从&lt;a href=&#34;http://developers.douban.com/wiki/?title=api_v2&#34;&gt;这里&lt;/a&gt;查看详细。需要注意的是必须设置&lt;code&gt;User-Agent&lt;/code&gt;这个请求头，否则返回的就是500错误了。
          httpGet.setHeader(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.22 (KHTML,     like Gecko) Chrome/25.0.1364.172 Safari/537.22&#34;);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至于android那边我用的HttpClient，这个很简单的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String uString= Douban.HOST + &#34;search?q=&#34; + ch + &#34;&amp;amp;start=&#34; + off + &#34;&amp;amp;count=&#34; +   Douban.PAGE_SIZE;
HttpGet httpGet = new HttpGet(uString);
HttpParams httpParams = new BasicHttpParams();  
HttpConnectionParams.setConnectionTimeout(httpParams,  
         Douban.NET_TIME_OUT);  
HttpConnectionParams.setSoTimeout(httpParams,  
     Douban.NET_TIME_OUT); 
httpGet.setParams(httpParams);
//X，竟然要模仿浏览器
httpGet.setHeader(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.22 (KHTML, like         Gecko) Chrome/25.0.1364.172 Safari/537.22&#34;);
HttpClient httpclient = new DefaultHttpClient();
HttpResponse response = httpclient.execute(httpGet);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;android3.0以后就不能从主线程中访问网络了，否则就会抛出一个异常&lt;code&gt;NetworkOnMainThreadException&lt;/code&gt;，而且是&lt;code&gt;RuntimeException&lt;/code&gt;，需要注意，可以用Handler或者是AsyncTask来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片的下载也是，因为图片的下载肯定也是异步的，所以不能在当前网络线程中访问，更不能在主线程里面处理，最好再起一个线程，这里推荐&lt;code&gt;AsyncTask&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public class ImageLoader extends AsyncTask&amp;lt;Integer, Integer, String&amp;gt; {

    private ImageView imgView;
    private String url = null;
    private Bitmap bm = null;

    public ImageLoader(ImageView imgView, String url) {  
        super();  
        this.imgView = imgView;
        this.url = url;
    }

    @Override
    protected String doInBackground(Integer... arg0) {

        InputStream is = null;
        URL aryURI = null;
        try {
            aryURI = new URL(url);
            is = aryURI.openStream();
            bm = BitmapFactory.decodeStream(is);

        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            try {
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    @Override
    protected void onPostExecute(String result) {
        this.imgView.setImageBitmap(bm);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有很多的不完善之处，比如图片的缓存处理，甚至是JSON数据的缓存处理，还有推出后恢复现场的处理，而且还可以接入douban更多的接口，UI也不是很好看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以从&lt;a href=&#34;http://vagascanner.googlecode.com/files/FDouBan.zip&#34;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-09</pubDate>  
    </item>  
    <item>  
		<title>Nginx 常用配置</title>  
		<link>http://blog.codecos.com//posts/Nginx-chang-yong-pei-zhi.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用Nginx做Web服务器，如果没有处理好日志，日志文件可能会很恐怖~10G、20G
可以修改nginx.conf 找到access_log：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;access_log /dev/null;
error_log /dev/null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样全部把他们丢到系统的黑洞里了
不用每时每刻都往系统磁盘疯狂的读写日志了 还延长硬盘的寿命&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查配置 &lt;code&gt;/usr/local/webserver/nginx/sbin/nginx -t&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启nginx和php-fpm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/php-fpm restart
killall -v nginx ; service nginx start
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载配置 &lt;code&gt;/usr/local/nginx/sbin/nginx -s reload&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是反向代理获得真实IP
  先在代理配置中加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_set_header        Host $host; 
proxy_set_header        X-Real-IP $remote_addr; 
proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，重载配置，可以从$_SERVER[&#39;HTTP_X_REAL_IP&#39;] 和 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]获取真实IP如果是服务器是Nginx，可以直接去，如果是Apache需要安装apache的一个第三方模块&#34;mod_rpaf&#34;了, 官方网站: http://stderr.net/apache/rpaf/。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用fcgi_cache来减少CPU压力&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fastcgi_cache_path /data/ngx_fcgi_tmp  levels=1:2  keys_zone=cache_php:30m inactive=1d                max_size=10g;
fastcgi_cache   cache_php;
fastcgi_cache_valid   200 302  1h;
fastcgi_cache_min_uses  1;
fastcgi_cache_use_stale error  timeout invalid_header http_500;
fastcgi_cache_key $host$request_uri;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：
 &lt;code&gt;fastcgi_cache_path：fastcgi_cache&lt;/code&gt;缓存目录，可以设置目录层级，比如1:2会生成16*256个字目录，cache_php是这个缓存空间的名字，cache是用多少内存（这样热门的内容nginx直接放内存，提高访问速度），inactive表示默认失效时间，max_size表示最多用多少硬盘空间。本来还有个fastcgi_temp_path参数，但发现似乎没用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fastcgi_cache_valid&lt;/code&gt;：定义哪些http头要缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi_cache_min_uses&lt;/code&gt;：URL经过多少次请求将被缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi_cache_use_stale&lt;/code&gt;：定义哪些情况下用过期缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi_cache_key&lt;/code&gt;：定义fastcgi_cache的key，示例中就以请求的URI作为缓存的key，Nginx会取这个key的md5作为缓存文件，如果设置了缓存哈希目录，Nginx会从后往前取相应的位数做为目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastcgi_cache&lt;/code&gt;：用哪个缓存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx 禁止IP访问&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
        listen       80 default_server;
        return       500;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止指定文件类型的访问 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location ~ /.*\.pem {
        deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-09</pubDate>  
    </item>  
    <item>  
		<title>博客换了新的主题了</title>  
		<link>http://blog.codecos.com//posts/bo-ke-huan-le-xin-de-zhu-ti-le.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;终于将新的主题换了上去，不过好像还没有之前的顺眼，但是之前的主题不适合内容展示，所以没办法，只能换一个了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;后台还是一如之前的简单，没有列表，只有一个添加和编辑页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 准备加入：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;草稿功能&lt;/li&gt;
&lt;li&gt;图片上传功能&lt;/li&gt;
&lt;/ul&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-08</pubDate>  
    </item>  
    <item>  
		<title>PHP数组的插入顺序</title>  
		<link>http://blog.codecos.com//posts/PHP-shu-zu-de-cha-ru-shun-xu.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;这个问题，纠结了我2个小时，一直的找bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;其实就是以为php数组如果是整形键值的话，会自动的按数值的从大到小排序，其实呢，人家php才不管它的key是什么，它都一视同仁，不管是数值还是字符串都是按照插入顺序的。&lt;/li&gt;
&lt;li&gt;是的，其实php的数组更像是map，但是它又维持着插入顺序，好吧，主要是自己想当然的，记在这里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;罪魁祸首就是它：&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private function _fillEmptyPaytype($paytypes){
    foreach($this-&amp;gt;PAY_TYPES as $pk=&amp;gt;$pv){
        if(!isset($paytypes[$pk])){
           $paytypes[$pk] = &#39;0.00&#39;;
        }
    }
    ksort($paytypes);
    return $paytypes;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上，加上&lt;strong&gt;ksort&lt;/strong&gt;就可以了。&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-07</pubDate>  
    </item>  
    <item>  
		<title>Nginx中一个server配置多个location</title>  
		<link>http://blog.codecos.com//posts/Nginx-zhong-yi-ge-server-pei-zhi-duo-ge.html</link>  
		<description>&lt;h5&gt;nginx中的location的匹配规则是“先匹配正则，再匹配普通”，同级的就是先后顺序了。&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;我这里需要实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个server中配置两个location对应不同的root目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个location分别对应不同的phpfpm代理的location配置  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个特定的url使用一个别名，这里要用别名，不要用root，alias指定的目录是准确的，root是指定目录的上级目录 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  location /texasholdem/bug/ {
       alias /data1/www/texasholdem/bug/;
       index  index.php index.html index.htm ;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定域名的配置  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; location / {
     root   /data1/www/wp/; 
     index  index.php index.html index.htm ;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应特定的url的phpfpm配置，注意root的值，root就是document_root
因为就上文来说document_root就是/data1/www/，这里不能用alias。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; location ~ /texasholdem/bug/(.*)\.php$ {
    root           /data1/www/;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_intercept_errors on;
    fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;
    include        fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;域名的php配置，只要配置相同的root就行了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
    root           /data1/www/wp/;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_intercept_errors on;
    fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;
    include        fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>新增了一个相册</title>  
		<link>http://blog.codecos.com//posts/xin-zeng-le-yi-ge-xiang-ce.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;里面都是GF的图片，为此她埋怨我了不少，哈哈。可以通过 &lt;a href=&#34;http://codecos.com/photo/&#34;&gt;这里&lt;/a&gt;访问&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实还可以点击rss图标旁边的图标访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个相册里面的图片是放在&lt;a href=&#34;http://qiniu.com&#34;&gt;七牛云存储&lt;/a&gt;上面的，这里小小的给它打个广告，真心不错，免费配额也是挺多的，而且提供的SDK也挺方便使用，速度也挺不错，推荐下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;相册是使用的&lt;a href=&#34;http://www.marcofolio.net/webdesign/creating_a_polaroid_photo_viewer_with_css3_and_jquery.html&#34;&gt;polaroid photo viewer&lt;/a&gt;，只需要简单的引入css和JS后&lt;/li&gt;
&lt;li&gt;然后就是&lt;a href=&#34;http://www.lokeshdhakar.com/projects/lightbox2/&#34;&gt;lightbox2&lt;/a&gt;了，这个很简单了。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;之前百度一直不收录，买了个&lt;a href=&#34;http://codecos.com&#34;&gt;域名&lt;/a&gt;，可是让我肉痛了几下，准备多学学SEO的知识了，这个就当作学习成本吧，哈哈。&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>最近准备干啥</title>  
		<link>http://blog.codecos.com//posts/zui-jin-zhun-bei-gan-sha.html</link>  
		<description>&lt;blockquote&gt;
&lt;p&gt;想练一练Java，具体来说是Android，预备是两个：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;豆瓣的电影搜索，以前做过一部分，不过很丑，而且现在它的API升级了&lt;/li&gt;
&lt;li&gt;关于本博客的Android客户端，其实就是一个写博客的工具而已，很简单的。&lt;/li&gt;
&lt;/ol&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-04</pubDate>  
    </item>  
    <item>  
		<title>Nginx中alias和root的区别(转)</title>  
		<link>http://blog.codecos.com//posts/Nginx-zhong-alias-he-root-de-qu-bie-zhuan.html</link>  
		<description>&lt;p&gt;nginx貌似没有虚拟目录的说法，因为它本来就是完完全全根据目录来设计并工作的。&lt;/p&gt;
&lt;p&gt;如果非要给nginx安上一个虚拟目录的说法，那就只有alias标签比较“像”，干脆来说说alias标签和root标签的区别吧。&lt;/p&gt;
&lt;p&gt;最基本的区别：alias指定的目录是准确的，root是指定目录的上级目录，并且该上级目录要含有location指定名称的同名目录。使用alias标签的目录块中不能使用rewrite的break。&lt;/p&gt;
&lt;p&gt;说不明白，看下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {
    alias /home/html/abc/;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段配置下，http://test/abc/a.html 就指定的是 /home/html/abc/a.html。这段配置亦可改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {
    root /home/html/;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，nginx就会去找/home/html/目录下的abc目录了，得到的结果是相同的。&lt;/p&gt;
&lt;p&gt;但是，如果我把alias的配置改成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /abc/ {
    alias /home/html/def/;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么nginx将会从/home/html/def/取数据，这段配置还不能直接使用root配置，如果非要配置，只有在/home/html/下建立一个 def-&amp;gt;abc的软link（快捷方式）了。&lt;/p&gt;
&lt;p&gt;一般情况下，在location /中配置root，在location /other中配置alias是一个好习惯。&lt;/p&gt;
&lt;p&gt;至于alias和root的区别，我估计还没有说完全，如果在配置时发现奇异问题，不妨把这两者换换试试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文链接：nginx 虚拟目录？的配置[http://www.sudone.com/nginx/nginx_alias.html]&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-08-01</pubDate>  
    </item>  
    <item>  
		<title>netbeans英文字体修改</title>  
		<link>http://blog.codecos.com//posts/netbeans-ying-wen-zi-ti-xiu-gai.html</link>  
		<description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;JDK_HOME/jre/lib&lt;/code&gt; 目录下的&lt;code&gt;fontconfig.properties.src&lt;/code&gt;复制一份文件&lt;code&gt;fontconfig.properties&lt;/code&gt;，并放在该目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑文件&lt;code&gt;fontconfig.properties&lt;/code&gt;，查找到下面一行：&lt;br /&gt;
&lt;code&gt;sequence.monospaced.GBK=chinese-ms936, alphabetic,dingbats,symbol&lt;/code&gt;&lt;br /&gt;
可以发现由于中文&lt;strong&gt;monospaced&lt;/strong&gt;字体缺省查找顺序是先使用&lt;strong&gt;chinese-ms936&lt;/strong&gt;，结果造成了英文被宋体来          显示。纠正非常简单，只需将&lt;strong&gt;chinese-ms936&lt;/strong&gt;和&lt;strong&gt;alphabetic&lt;/strong&gt;调换顺序就可以了： 
&lt;code&gt;sequence.monospaced.GBK=alphabetic,chinese-ms936,dingbats,symbol&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;google开始收录这个博客了，可是百度还说我没有添加网站。法克！&lt;/p&gt;
&lt;/blockquote&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-07-31</pubDate>  
    </item>  
    <item>  
		<title>修改博客的编辑器为Markdown</title>  
		<link>http://blog.codecos.com//posts/xiu-gai-bo-ke-de-bian-ji-qi-wei.html</link>  
		<description>&lt;ul&gt;
&lt;li&gt;采用的是&lt;a href=&#34;http://oscargodson.github.io/EpicEditor/&#34;&gt;EpicEditor&lt;/a&gt;
语法链接在上面有，其实挺简单的，比KindEditor来说，虽然功能上面肯定要弱很多，但是很能激发起写作的欲望，以后多在这里写一些东西。&lt;/li&gt;
&lt;li&gt;本博客的github地址为：&lt;a href=&#34;https://github.com/daimin/tolog&#34;&gt;https://github.com/daimin/tolog&lt;/a&gt;，欢迎过来提意见&lt;blockquote&gt;
&lt;p&gt;其实我觉得用了markdown以后文章的标题好像成了鸡肋了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2013-07-30</pubDate>  
    </item>  
    <item>  
		<title>jVaga，蛋疼的JS库</title>  
		<link>http://blog.codecos.com//posts/jVaga-dan-teng-de-JS-ku.html</link>  
		<description>&lt;p&gt;很简单的，没多少代码，应该还有很多BUG，先做个标记在这里。
我的目标就是 &lt;strong&gt;Make you easy use&lt;/strong&gt;。
主要就是模仿Jquery的使用，肯定没有jquery强大，但是肯定也要简单许多。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能使用jVaga.extend进行对象扩展(prototype.js)。&lt;/li&gt;
&lt;li&gt;能进行简单的浏览器类型判断，jVaga.B，如果是IE则会返回IE版本号，如果是其它浏览器只会是布尔值。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能使用jVaga()或者$，进行元素选择，你也可以使用jVaga.util.setNamespace自定义选择器标志符。
   选择器返回的是包装后的JS对象，你可以直接调用它提供的各种便利的方法。&lt;/p&gt;
&lt;p&gt;选择器用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&#34;cn&#34;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&#34;utf-8&#34; /&amp;gt;
&amp;lt;script type=&#34;text/javascript&#34; src=&#34;jvaga-0.3.0.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;script type=&#34;text/javascript&#34;&amp;gt;
/*        window.onload = function(){
                var dd = document.getElementById(&#34;track&#34;);
                alert(dd.getAttribute);
          }
 */
           $(function(){

 // test1 : 命名空间设置             
 //             jVaga.util.setNamespace(&#34;$_$&#34;);
 //             alert($_$(&#34;#track&#34;));
 // test : id
 //             alert($(&#34;#track&#34;));
 /*$(&#34;.logo&#34;).each(function(e){
   alert(e.hasClass(&#34;logo1&#34;));
 });
 */
 // class 选择，class检测, find二次选择，属性值获取,tagName选择
 //alert($(&#34;.logo&#34;)[0].hasClass(&#34;logo&#34;));
 //alert($(&#34;.logo&#34;)[0].find(&#34;img&#34;)[0].attr(&#39;src&#39;));
 //alert($(&#34;a&#34;)[0].text());
 // 链式使用
 //alert($(&#34;.logo&#34;)[0].find(&#34;img&#34;)[0].attr(&#39;src&#39;,&#39;xxxx.gif&#39;).attr(&#39;src&#39;));
 // $(&#34;#ddd&#34;) $(&#34;[name=&#39;sds&#39;]:first &amp;gt; &#34;) $(&#34;input&#34;) 
 // 浏览器测试
 //alert($.B.IE);
 //alert($.B.OP);
 //alert($.B.WK);
 //alert($.B.GK);
 //alert($.B.MS);

           });
         &amp;lt;/script&amp;gt;
     &amp;lt;/head&amp;gt;
     &amp;lt;body&amp;gt;

       &amp;lt;div class=&#34;header&#34;&amp;gt;
           &amp;lt;div class=&#34;logo&#34;&amp;gt;&amp;lt;img src=&#34;images/logo.png&#34; /&amp;gt;&amp;lt;/div&amp;gt;
           &amp;lt;div id=&#34;track&#34;&amp;gt;
            &amp;lt;a href=&#34;#&#34;&amp;gt;首页&amp;lt;/a&amp;gt;
            &amp;lt;span class=&#34;arrow&#34;&amp;gt;&amp;amp;gt;&amp;amp;gt;&amp;lt;/span&amp;gt;
            绘图优化
         &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
      &amp;lt;div id=&#34;main&#34;&amp;gt;
       &amp;lt;div class=&#34;blocks&#34;&amp;gt;

         &amp;lt;div id=&#34;leaveBlank&#34;&amp;gt;
            想象力的留白
       &amp;lt;/div&amp;gt;

     &amp;lt;div class=&#34;block&#34;&amp;gt;
          &amp;lt;div id=&#34;userInfo&#34;&amp;gt;
              &amp;lt;h3&amp;gt;个人信息&amp;lt;/h3&amp;gt;
             &amp;lt;img src=&#34;images/userhead.jpg&#34;&amp;gt;
          &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
           &amp;lt;div class=&#34;article&#34;&amp;gt;
           &amp;lt;div class=&#34;title&#34;&amp;gt;
               &amp;lt;div class=&#34;title_cont&#34;&amp;gt;
                   我的文章标题
               &amp;lt;/div&amp;gt;
               &amp;lt;div class=&#34;tag&#34;&amp;gt;
                   标签1 标签2
               &amp;lt;/div&amp;gt;
           &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;

     &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jVaga.util下面有各种的工具函数，如：&lt;br /&gt;
    toArray函数将参数转换成数组；addClass2TagNext给指定的标签的元素的下一个元素节点运用class；
    loadScript函数动态加载JS包；getEvent函数，兼容浏览器的Event对象的获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给数组类型加入了each函数，能方便的遍历每个元素；给String加入了trim函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了便利的Ajax支持，（为提供效率，使用了HttpRequest对象连接池，不知道是不是好的实践呢？）jVaga.Post对应post方式的AJax请求，jVaga.get就是get方式的了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以自由的使用该工具，但是本人不保证其效率及功能的完整性，如果能有任何的反馈，我会很乐意的修改，如果你能将该工具用于任何的项目中，我也十分的荣幸，不过请保留本人的名字。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;一不小心就0.3.1版本了，主要做了如下修改：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这个版本主要对于节点选择器内部实现的改进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单来说，因为IE8+及Chrome、Safari、Firefox比较新的版本中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;都实现了比较好的选择器querySelector及querySelectorAll，这些选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比我用Javascript实现的选择器，效率不知高多少倍，所以我在内部需要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适配使用该接口实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只是针对Css ClassName的选择的时候，应用了querySelectorAll,其它的情况下
  也是无法应用该接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而用法还是如上面，所示：&lt;br /&gt;
新版本的代码在&lt;a href=&#34;http://vagascanner.googlecode.com/files/jvaga-0.3.1.js&#34;&gt;这里下载&lt;/a&gt;&lt;/p&gt;</description>  
		<author>daimin</author>  
		<copyright></copyright>  
		<pubDate>2011-07-12</pubDate>  
    </item>  
</channel>  
</rss>  
